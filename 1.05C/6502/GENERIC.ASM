; --------------------------------
; ASSEMBLE ONE LINE
ASM:	TSX

; SAVE STACK SO EVERY ERROR
; CAN RETURN HERE REGARDLESS OF
; STACK CONTENTS
	STX	STK
	LDY	#0
	STY	BINLEN
	LDA	FUNC
	BPL	ASMLIN
	STY	TXTLEN

; WRITE LABEL IF SYMBOLS ARE TO
; BE READ
	LDA	FUNC
	AND	#2
	BEQ	NOSYM
	LDA	PC
	STA	IMM
	LDA	PC+1
	STA	IMM+1
	LDA	#$0C
	STA	SYMFLG
	LDX	#SYM
	JSR	SDEF
	BEQ	NOSYM
	LDY	#0
WSYML:	LDA	(TABLE),Y
	INY
	CMP	#$21
	BCS	WSYML

; WRITE SYMBOL IF IT IS NOT
; AN EQUATE
	AND	#2
	BNE	NOSYM
	JSR	WRM
	LDA	#$3A
	STA	(TXTBUF),Y
	INY
NOSYM:	JSR	RDBIN
	STA	OPCODE
	LDA	#9
	STA	(TXTBUF),Y
	INY
	JSR	DISASM
	LDA	#$0D
	STA	(TXTBUF),Y
	INY
	LDA	#$0A
	STA	(TXTBUF),Y
	INY
	STY	TXTLEN
	LDA	BINLEN
	LDX	#PC

; --------------------------------
; ADD ACCUMULATOR TO 16-BIT
; NUMBER IN MEMORY
ADDA:	PHA
	CLC
	ADC	0,X
	STA	0,X
	LDA	#0
	ADC	1,X
	STA	1,X
	PLA
	CLC
	RTS
ASMLBL:	JSR	LBL

; RESET STACK JUST IN CASE WE
; GOT BACK HERE FROM SOME OR
; OTHER ODD PLACE
ASMLIN:	LDX	STK
	TXS
	JSR	CC
	BEQ	SETEQ0

; EQUAL SIGN WORKS LIKE AN EQU
	CMP	#$3D
	BEQ	ASMEQU

; SET PROGRAM COUNTER BY CHARACTER
	CMP	#PCCHAR
	BEQ	ASMORG
	JSR	ASMCMD
	BNE	ASMLBL
	JSR	CC
	BEQ	SETEQ0

; CHARACTERS PAST END OF LINE
; ERROR
	LDA	#9
	JMP	FAIL
ASMEQU:	INC	TXTBUF
	BEQ	SETEQU
	INC	TXTBUF+1

; --------------------------------
; EQU DIRECTIVE OR EQUAL SIGN
SETEQU:	LDA	FUNC
	AND	#3
	BEQ	SETEQ0

; GET OR CALCULATE IMMEDIATE
; AND STORE IT AT POINTER
; GENERATED BY LBL
	JSR	RE
	LDY	#0
	LDA	#2
	ORA	(SYMPTR),Y
	STA	(SYMPTR),Y
	INY
	LDA	IMM
	STA	(SYMPTR),Y
	INY
	LDA	IMM+1
	STA	(SYMPTR),Y
SETEQ0:	CLC
	RTS
ASMORG:	INC	TXTBUF
	BEQ	ASMOR1
	INC	TXTBUF+1
ASMOR1:	JSR	CC
	BEQ	ASMOER
	CMP	#$3D
	BNE	ASMOER
	INC	TXTBUF
	BEQ	SETORG
	INC	TXTBUF+1

; --------------------------------
; ORG DIRECTIVE
SETORG:	JSR	RE
	LDA	PC
	STA	TEMP
	LDA	PC+1
	STA	TEMP+1
	LDA	IMM
	STA	PC
	LDA	IMM+1
	STA	PC+1

; CHECK FOR START OF PROGRAM
	LDA	TEMP
	CMP	VORG
	BNE	SETOR1
	LDA	TEMP+1
	CMP	VORG+1
	BNE	SETOR1

; SET LOAD ADDRESS AT
; PROGRAM START
	LDY	#3
	LDA	IMM
	STA	(SYM),Y
	INY
	LDA	IMM+1
	STA	(SYM),Y
SETOR0:	CLC
	RTS

; IF NEW ADDRESS IS AHEAD,
; DEFINE AS EMPTY SPACE
SETOR1:	SEC
	LDA	IMM
	SBC	TEMP
	STA	IMM
	LDA	IMM+1
	SBC	TEMP+1
	STA	IMM+1
	BMI	SETOR0
	LDX	#USIZE
	JMP	ADDI

; SYNTAX ERROR
ASMOER:	LDA	#1
	JMP	FAIL

; --------------------------------
; SCAN FOR TOKENS AT TXTBUF
; SET TXTBUF TO FIRST TOKEN
; LOCATION, Y TO LENGTH, A TO
; FIRST CHAR
CC:	LDY	#0
CCM:	LDA	(TXTBUF),Y
	BEQ	CCT
	CMP	#$0D
	BEQ	CCT
	CMP	#$21
	BCC	CCK
	CMP	#$22
	BEQ	CCQ
	CMP	#$27
	BEQ	CCQ
	CMP	#$30
	BCC	CCS
	CMP	#$3A
	BCC	CCL
	CMP	#$3B
	BEQ	CCT
	CMP	#$41
	BCC	CCS
	CMP	#$5B
	BCC	CCL
	CMP	#$5F
	BEQ	CCL
	CMP	#$61
	BCC	CCS
	CMP	#$7B
	BCS	CCS

; CONVERT NORMAL LETTER
; TO UPPERCASE
	AND	#$DF
	STA	(TXTBUF),Y

; INCREMENT TOKEN LENGTH
CCL:	INY
	BNE	CCM

; IF THERE IS A TOKEN, ABORT
; AND RETURN IT, OTHERWISE
; SKIP SPACE
CCK:	CPY	#0
	BNE	CCT
	INC	TXTBUF
	BNE	CCM
	INC	TXTBUF+1
	BNE	CCM

; IF THERE IS ALREADY A TOKEN
; ABORT AND RETURN EXISTING
; TOKEN, OTHERWISE RETURN
; SPECIAL CHARACTER
CCS:	CPY	#0
	BEQ	CCE

; ABORT AND RETURN FIRST
; CHARACTER ON LINE AND
; SET ZERO FLAG
CCT:	STY	YSAVE
	LDY	#0
	LDA	(TXTBUF),Y
	LDY	YSAVE
	CPY	#0
	RTS

; IF TOKEN EXISTS, ABORT AND
; RETURN TOKEN, OTHERWISE
; SCAN UNTIL NEXT MATCHING
; QUOTE AND RETURN QUOTED
; TEXT AS TOKEN
CCQ:	CPY	#0
	BNE	CCT
CCW:	INY
	CMP	(TXTBUF),Y
	BNE	CCW
CCE:	INY
	RTS

; --------------------------------
; TEST IF 16-BIT SIGNED NUMBER
; CAN UNAMBIGUOUSLY FIT WITHIN
; 8 BITS
AA:	LDA	0,X
	AND	#$80
	BNE	AA1

; IF SIGN BIT IS NOT SET ON
; LOWER BYTE, UPPER BYTE MUST
; BE ZERO
	LDA	1,X
	RTS

; IF SIGN BIT IS SET ON LOWER
; BYTE, UPPER BYTE MUST BE FF
AA1:	LDA	1,X
	CMP	#$FF
	RTS

; --------------------------------
; SCAN SYMBOL TABLE FOR TOKEN
; AND RETURN DEFINITION IF FOUND
SL:	LDA	0,X
	STA	TABLE
	LDA	1,X
	STA	TABLE+1
	STY	YSAVE

; GET SYMBOL COUNT AND SET UP
; TEMPORARY COUNTER
	LDY	#0
	LDA	(TABLE),Y
	STA	TEMP
	INY
	LDA	(TABLE),Y
	STA	TEMP+1

; ADVANCE TABLE POINTER
SLMAIN:	TYA
	LDX	#TABLE
	JSR	ADDA

; DECREMENT COUNTER
	LDX	#TEMP
	JSR	DEC16
	BMI	SKIP2

; GET ENTRY LENGTH AND CHECK
; WITH SYMBOL; SET Y TO -1
; FIRST TO BE ABLE TO
; PREINCREMENT
	LDA	#$20
	LDY	#$FF
SLMSR:	INY
	CMP	(TABLE),Y
	BCC	SLMSR
	CPY	YSAVE
	BNE	SLNOT

; CHECK ENTRY AGAINST SYMBOL
SLSCAN:	DEY
	BMI	SLGOT
	LDA	(TXTBUF),Y
	CMP	(TABLE),Y
	BEQ	SLSCAN
	LDY	YSAVE

; ADD TWO BYTES FOR THE
; ENTRY DEFINITION
SLNOT:	INY
	INY
	BNE	SLMAIN

; LOAD DEFINITION INTO
; TEMPORARY STORAGE
SLGOT:	LDY	YSAVE
	INY
	LDA	(TABLE),Y
	STA	TEMP
	INY
	LDA	(TABLE),Y
	STA	TEMP+1
	DEY
	DEY

; SKIP PAST SYMBOL ON LINE
SKIPTX:	LDX	#TXTBUF

; --------------------------------
; SKIP AHEAD IN BUFFER BY Y
SKIP:	INC	0,X
	BNE	SKIP1
	INC	1,X
SKIP1:	DEY
	BNE	SKIP
SKIP2:	RTS

; --------------------------------
; SCAN SYMBOL TABLE BY AX FOR
; DEFINITION, ACCORDING TO SYMFLG,
; AND RETURN SYMBOL
SDEF:	LDA	0,X
	STA	TABLE
	LDA	1,X
	STA	TABLE+1
	STY	YSAVE
	LDY	#0

; GET SYMBOL COUNT AND SET UP
; TEMPORARY COUNTER
	LDA	(TABLE),Y
	STA	TEMP
	INY
	LDA	(TABLE),Y
	STA	TEMP+1
	INY
	INY
	BNE	SDEF6

; GET ENTRY LENGTH
SDEF1:	LDY	#0
SDEF2:	LDA	(TABLE),Y
	INY
	CMP	#$21
	BCS	SDEF2
	INY

; CHECK DEFINITION
	LDA	SYMFLG
	AND	#$0C
	BEQ	SDEF4
	CMP	#$0C
	BEQ	SDEF3
	AND	#8
	BEQ	SDEF5

; HIGH BYTE
	LDA	(TABLE),Y
	CMP	IMM
	BNE	SDEF7
	RTS

; FULL WORD
SDEF3:	LDA	(TABLE),Y
	CMP	IMM+1
	BNE	SDEF7
	BEQ	SDEF5

; SIGNED BYTE
; FALLS THROUGH TO LOW BYTE
SDEF4:	LDA	(TABLE),Y
	BEQ	SDEF5
	CMP	#$FF
	BNE	SDEF7
	DEY
	LDA	(TABLE),Y
	BPL	SDEF6
	INY

; LOW BYTE
SDEF5:	DEY
	LDA	(TABLE),Y
	CMP	IMM
	BNE	SDEF6
	RTS
SDEF6:	INY
SDEF7:	INY

; ADVANCE TABLE POINTER
	TYA
	LDX	#TABLE
	JSR	ADDA

; DECREMENT COUNTER
	LDX	#TEMP
	JSR	DEC16
	BNE	SDEF1
	LDA	#1
	RTS

; --------------------------------
; THIS IS A MUNDANE BY-THE-BOOK
; HEX CONVERSION. SURELY IT IS
; FAMILIAR ENOUGH.
HALX:	PHA
	LSR	A
	LSR	A
	LSR	A
	LSR	A
	JSR	HALL
	PLA
HALL:	AND	#$0F
	ORA	#$30
	CMP	#$3A
	BCC	HALN
	ADC	#6

; WRITE CHARACTER TO
; TEXT BUFFER
HALN:	STA	(TXTBUF),Y
	INY

; AND DON'T CALL ME SHIRLEY
	RTS

; --------------------------------
; READ 16-BIT NUMBER IN EITHER
; BINARY, OCTAL, HEX, OR DECIMAL
; AS DEFINED BY ROTATION COUNT
; IN X
RN:	STY	YSAVE
	LDY	#0

; BLANK OUT TEMPORARY STORAGE
	STY	TEMP
	STY	TEMP+1

; X BETWEEN 1 AND 4 WORKS WITH
; COMMON NUMBER BASES THAT ARE
; POWERS OF 2.  ANYTHING ELSE
; IS CHANGED TO ZERO WHICH WORKS
; WITH DECIMAL
	CPX	#5
	BCC	RN1
	LDX	#0
RN1:	TXA
RN2:	ASL	TEMP
	ROL	TEMP+1
	CPX	#0
	BNE	RN3

; IF NOTHING IN X, CONTINUE
; PROCESSING AS DECIMAL
	LDA	TEMP
	LDX	TEMP+1
	ASL	TEMP
	ROL	TEMP+1
	ASL	TEMP
	ROL	TEMP+1
	CLC
	ADC	TEMP
	STA	TEMP
	TXA
	ADC	TEMP+1
	STA	TEMP+1

; ENSURE EXPEDIENT TERMINATION
; OF THE LOOP
	LDX	#1

; THIS IS THE DECIMAL SECTION;
; ZERO OUT X SO IT DOESN'T GET
; ANY FUNNY IDEAS LATER
	LDA	#0
RN3:	DEX
	BNE	RN2
	TAX

; READ ONE DIGIT FROM LINE
	LDA	(TXTBUF),Y
	INY
	SEC
	SBC	#$30

; ANYTHING BELOW $30 WILL
; UNDERFLOW OUT OF ITS VALID
; DIAPAZON AND WILL NOT PASS THE
; FOLLOWING UPPER BOUNDARY TESTS
	CMP	#$0A
	BCC	RN4
	SBC	#7
	CMP	#$0F
	BCC	RN4
	BNE	RN5
RN4:	CLC
	ADC	TEMP
	STA	TEMP
	LDA	#0
	ADC	TEMP+1
	STA	TEMP+1
	CPY	YSAVE
	BCC	RN1
	JSR	SKIPTX

; IF THE TOKEN IS FULLY
; PROCESSED, Y WILL END UP
; TRIGGERING THE ZERO FLAG.  IF
; EXITED VIA THE EARLIER JUMP,
; THE ZERO FLAG ISN'T SET,
; SIGNALING AN INVALID DIGIT.
RN5:	RTS

; --------------------------------
; WRITE 16-BIT NUMBER TO TEXT
; BUFFER AS A NUMERIC CONSTANT
; WITHOUT LEADING ZEROES
; IN BASE SPECIFIED BY
; ROTATION COUNT IN X
WN:	STX	XSAVE
	STY	YSAVE
	LDA	#$FF
	CPX	#0
	BEQ	WDA
	CPX	#5
	BCS	WDA
	LDY	#0
	PHA

; BASES 2, 4, 8, AND 16 CAN
; BE HANDLED WITH SHIFTS
WN1:	LDA	#0
	LDX	XSAVE
WN2:	LSR	TEMP+1
	ROR	TEMP
	ROR	A
	DEX
	BNE	WN2

; GET IT BACK INTO POSITION
	LDX	XSAVE
	ASL	A
WN3:	ROL	A
	DEX
	BNE	WN3
	PHA

; END WHEN NO MORE MAIN VALUE
	CLC
	LDA	TEMP
	ADC	TEMP+1
	BNE	WN1
	PLA
	BPL	WDA4

; BASE 10 REQUIRES TRICKERY
WDA:	LDA	#$FF
WDA1:	PHA
	LDA	#0
	TAY
	LDX	#$10
WDA2:	CMP	#5
	BCC	WDA3
	SBC	#5
	INY
WDA3:	ROL	TEMP
	ROL	TEMP+1
	ROL	A
	DEX
	BNE	WDA2
	DEY
	BPL	WDA1

; GET Y BACK TO END OF
; CURRENT OUTPUT
	LDY	YSAVE
WDA4:	JSR	HALL
	PLA
	BPL	WDA4
	RTS

; --------------------------------
; ADD SYMBOL TO SYMBOL TABLE
; OR REDEFINE EXISTING SYMBOL
LBL:	JSR	CC
	LDA	FUNC
	AND	#3
	BEQ	ERR3

; PROCESS DETECTED SYMBOL
	LDX	#SYM
	JSR	SL
	BNE	LBL1

; SYMBOL EXISTS, BUT CAN BE
; REDEFINED ON FUNCTION 2
	LDA	FUNC
	AND	#2
	BNE	LBL3

; DUPLICATE SYMBOL ERROR
	LDA	#$0A
	JMP	FAIL

; WRITE SYMBOL TO TABLE
LBL1:	LDY	YSAVE
	LDA	#0
	STA	(TABLE),Y
	DEY
LBL2:	LDA	(TXTBUF),Y
	STA	(TABLE),Y
	DEY
	BPL	LBL2

; SKIP PAST SYMBOL ON LINE
	LDY	YSAVE
	JSR	SKIPTX

; INCREASE SYMBOL COUNT
	TYA
	SEC
	ADC	(SYM),Y
	STA	(SYM),Y
	TYA
	INY
	ADC	(SYM),Y
	STA	(SYM),Y

; ADVANCE TABLE POINTER
LBL3:	LDX	#TABLE
	LDY	YSAVE
	JSR	SKIP

; SAVE POINTER TO ENTRY
	LDA	TABLE
	STA	SYMPTR
	LDA	TABLE+1
	STA	SYMPTR+1

; GET CURRENT PROGRAM COUNTER
; AND STORE IN TABLE WITH THE
; NEW ENTRY
	INY
	LDA	PC
	STA	(TABLE),Y
	INY
	LDA	PC+1
	STA	(TABLE),Y

; CHECK FOR COLON OR INSTRUCTION
	JSR	CC
	BEQ	ERR3
	CMP	#$3A
	BNE	LBL4

; SKIP COLON
	INC	TXTBUF
	BNE	LBL4
	INC	TXTBUF+1
LBL4:	RTS

; INVALID INSTRUCTION ERROR
ERR3:	LDA	#3
	JMP	FAIL

; --------------------------------
; PROCESS DFB/DFW DIRECTIVE
SETDFB:	LDA	#0
	STA	UDATA
SETDMA:	JSR	CC
	BEQ	ERR8
	CMP	#$3F
	BEQ	SETDUD

; DEFINED DATA IS DISCOVERED SO
; WRITE ALL PRECEDING UNDEFINED
; DATA TO BUFFER AS ZEROES
	PHA
	TYA
	PHA
	LDA	#0
	LDY	UDATA
	JSR	WBINA
	PLA
	TAY
	PLA
	CMP	#$22
	BEQ	SETDQU
	CMP	#$27
	BEQ	SETDQU
SETDVA:	JSR	RE

; WRITE ONLY THE NECESSARY
; AMOUNT OF BYTES
	LDX	#IMM
	LDY	#1
	CPY	OPCODE
	BCS	SETDVW
	INY
SETDVW:	JSR	WBINX

; SINCE THE DATA SCANNER AS
; IMPLEMENTED CURRENLY CAN ONLY
; HANDLE 16-BIT VALUES, LARGER
; DEFINITIONS MUST BE SIGN
; EXTENDED; HOWEVER, THAT IS
; COMMENTED OUT FOR NOW AS THERE
; ARE NO DEFINITION DIRECTIVES
; LARGER THAN DFW. IT WILL MOST
; LIKELY NEED TO BE PUT IN A
; SEPARATE SECTION AND JSR'ED;
; OTHERWISE IT'LL THROW THE
; LOCAL BRANCHES OUT OF
; DIAPAZON.
;	LDA	OPCODE
;	SEC
;	SBC	#2
;	BCC	SETDCM
;	BEQ	SETDCM
;	TAY
;	LDA	IMM+2
;	EOR	#$80
;	ASL	A
;	STA	ASAVE
;	SBC	ASAVE
;	JSR	WBINA
	BEQ	SETDCM

; IF ANY UNDEFINED DATA IS
; FOUND, ADD IT UP
SETDUD:	CLC
	LDA	OPCODE
	ADC	UDATA
	STA	UDATA
	JSR	SKIPTX
	BEQ	SETDCM

; QUOTED STRINGS OF LESS THAN 3
; BYTES ARE PROCESSED AS LITERAL
; BINARY CONSTANTS
SETDQU:	CPY	#4
	BCC	SETDVA

; WRITE ONLY WHAT IS BETWEEN THE
; QUOTATION MARKS
	DEY
	DEY
	STY	YSAVE

; SKIP FIRST MARK
	LDY	#1
	JSR	SKIPTX

; WRITE STRING TO OUTPUT,
; VERBATIM
	LDY	YSAVE
	JSR	WBINX

; SKIP STRING AND FINAL MARK
	LDY	YSAVE
	INY
	JSR	SKIPTX

; IF THERE ARE ANY MORE
; CHARACTERS ON THE LINE, THE
; FIRST MUST BE A COMMA
SETDCM:	JSR	CC
	BEQ	SETDEN
	CMP	#$2C
	BNE	ERR1
	JSR	SKIPTX
	BEQ	SETDMA

; ADD ANY UNDEFINED DATA TO THE
; ACCUMULATED AMOUNT AND UPDATE
; PC BY THE SAME AMOUNT.  THE
; ASM PROCEDURE WILL UPDATE PC
; BY THE LENGTH OF THE BINARY
; OUTPUT PRODUCED, I.E. HOW FAR
; THE BUFFER HAS BEEN SKIPPED
SETDEN:	LDX	#USIZE
	LDA	UDATA
	JSR	ADDA
	ADC	BINLEN
	STA	IMM
	LDA	#0
	ROL	A
	STA	IMM+1
	JMP	STDAT

; MISSING OPERAND ERROR
ERR8:	LDA	#8
	BNE	FAIL

; SYNTAX ERROR
ERR1:	LDA	#1
	BNE	FAIL

; --------------------------------
; PREPARE FILE NAME FOR
; INCLUDE DIRECTIVE
SETINC:	JSR	CC
	BEQ	ERR8
	CMP	#$22
	BEQ	SETIN1
	CMP	#$27
	BNE	SETIN3
SETIN1:	INC	TXTBUF
	BNE	SETIN2
	INC	TXTBUF+1

; IF ENCLOSED IN QUOTES, MUST
; BE AT LEAST 3 CHARACTERS LONG
; INCLUDING THE TWO MARKS
SETIN2:	DEY
	BEQ	ERR8
	DEY
	BEQ	ERR8
	BNE	SETEND

; IF NOT IN QUOTES, GET REST
; OF LINE UNTIL FIRST EMPTY
; SPACE OR SEMICOLON
SETIN3:	LDY	#0
SETIN4:	INY
	LDA	(TXTBUF),Y
	CMP	#$3B
	BEQ	SETEND
	CMP	#$21
	BCS	SETIN4

; PROCEED DIRECTLY INTO THE
; I/O HANDLER
SETEND:	LDA	OPCODE

; --------------------------------
; ERROR AND I/O HANDLER
FAIL:	LDX	STK

; RESET STACK TO TOP LEVEL
; CALLER, THE LINE ASSEMBLER
	TXS
	CMP	#5
	BNE	FAIL0

; ERROR CODE 5 IS RELATIVE JUMP
; OUT OF RANGE; CALCULATE THE
; ABSOLUTE AMOUNT OF BYTES
	LDA	IMM+1
	BPL	FAIL1
	EOR	#$FF
	STA	IMM+1
	LDA	IMM
	EOR	#$FF
	STA	IMM
FAIL1:	SEC
	LDA	IMM
	SBC	#$7F
	STA	IMM
	LDA	IMM+1
	SBC	#0
	STA	IMM+1
FAIL0:	SEC
	RTS

; --------------------------------
; PRIMITIVE EXPRESSION EVALUATOR
RE:	LDA	#0
	STA	IMM
	STA	IMM+1
	STA	SYMFLG
RE1:	JSR	CC
	BEQ	RE4
	TAX

; PREPARE TO SET ARITHMETIC
; OPERATOR FLAGS
	LDA	SYMFLG
	CPX	#$2B
	BEQ	RE3
	CPX	#$2D
	BEQ	RE2

; GV WILL APPLY THE OPERATOR
; AND RESET ITS FLAG
	JSR	GV
	BCS	RE4

; IF AN IDENTIFIER WAS FOUND,
; GV HAS SET ITS FLAG INSTEAD
	LDX	#TEMP
	JSR	IADD
	BCC	RE1

; USE OF AN OPERATOR WILL RESET
; THE IDENTIFIER FLAG
RE2:	EOR	#$80
RE3:	AND	#$BF
	STA	SYMFLG
	JSR	SKIPTX
	BEQ	RE1

; CHECK FOR OPERAND TO MAKE
; SURE THERE ARE NO DANGLING
; OPERATORS
RE4:	LDA	SYMFLG
	AND	#$40
	BEQ	GV8
	RTS

; --------------------------------
; HANDLE ONE NUMERIC CONSTANT
; OR IDENTIFIER AND GET VALUE
GV:	TAX

; CHECK FLAGS IF IDENTIFIER WAS
; ALREADY PROCESSED
	LDA	#$40
	BIT	SYMFLG
	BNE	GVA
	TXA
	CMP	#PCCHAR
	BEQ	GVC
	CMP	#$22
	BEQ	GVQ
	CMP	#$27
	BEQ	GVQ

; CHECK SIZE OVERRIDES AND START
; OVER IF THERE ARE ANY
	JSR	RNM
	BEQ	GV
	JSR	RNC
	BCC	GVV

; INVALID CHARACTERS MEANS THE
; END OF THE IDENTIFIER
	CMP	#$40
	BCC	GVA
	LDA	FUNC
	AND	#3
	BNE	GVL

; ONLY BOTHER READING LABELS
; IF THE FUNCTION IS SPECIFIED
; OTHERWISE JUST GET CURRENT PC
GVC:	JSR	SKIPTX
	LDA	SYMFLG
	ORA	#1
	STA	SYMFLG
	LDA	PC
	STA	TEMP
	LDA	PC+1
	STA	TEMP+1
	BCC	GVV

; CONSTANT TOO LARGE ERROR
GV7:	LDA	#7
	JMP	FAIL

; MISSING OPERAND ERROR
GV8:	LDA	#8
	JMP	FAIL

; RETURN WITH CARRY MEANS
; UNEXPECTED ENTRY OR END
; OF LINE
GVA:	SEC
	RTS
GVQ:	STY	YSAVE

; SAVE TWO PLACES PAST FIRST
; QUOTATION MARK
	LDY	#2
	LDA	(TXTBUF),Y
	STA	TEMP+1
	DEY
	LDA	(TXTBUF),Y
	STA	TEMP

; GO AHEAD AND SKIP EVERYTHING
	LDY	YSAVE
	JSR	SKIPTX
	LDY	YSAVE

; 5 CHARACTERS INCLUDING 2
; QUOTES MEANS 3 CHARACTER VALUE
; AND THAT IS EXCESSIVE
	CPY	#5
	BCS	GV7

; 2 CHARACTER VALUE MEANS WHAT
; WAS SAVED IS GOOD
	CPY	#4
	BCS	GVV

; 0 CHARACTER VALUE CANNOT BE
	CPY	#3
	BCC	GV8

; 1 CHARACTER MEANS UPPER BYTE
; OF TEMP VALUE MUST BE BLANKED
	LDA	#0
	STA	TEMP+1
	BEQ	GVV

; PROCESS SYMBOL REFERENCE
GVL:	LDX	#SYM
	JSR	SL
	BEQ	GVL1

; ONLY RAISE ALARM FOR MISSING
; IDENTIFIERS ON CODE 2 TO ALLOW
; CODE 1 TO COLLECT THEM AT A
; LEISURELY PACE
	LDA	#2
	BIT	FUNC
	BEQ	GVC

; SYMBOL NOT FOUND ERROR
	LDA	#4
	JMP	FAIL

; A FORWARD SYMBOL REFERENCE
; MUST RESOLVE TO A 16 BIT VALUE
; BUT THE SIZE OF A BACKWARD
; REFERENCE CAN BE 8 BITS AND
; DETECTED 8-BIT BACKWARD
; REFERENCES ARE THEREFORE
; MARKED WITH BIT 1 ON THE
; TERMINATOR CHARACTER WHICH
; CODE 2 WILL LOOK FOR;
; CONSEQUENTLY, IT MAY NOT BE
; SET DURING A CODE 2 SEQUENCE
GVL1:	LDY	IMM+1
	BNE	GVL3
	LDY	YSAVE
	BIT	FUNC
	BNE	GVL2
	LDA	#1
	ORA	(TABLE),Y
	STA	(TABLE),Y
GVL2:	LDA	(TABLE),Y
	LSR	A
	BCS	GVV
GVL3:	LDA	#2
	ORA	SYMFLG
	STA	SYMFLG

; SET IDENTIFIER FLAG
GVV:	LDA	#$40
	ORA	SYMFLG
	BPL	GVNS
	EOR	#$80

; IF MINUS FLAG IS SET, NEGATE
; ACQUIRED VALUE
	LDX	#TEMP
	JSR	WNEG

; ROTATE BITS OF SYMBOL FLAGS
; INTO CARRY TO CHECK FOR KNOWN
; SIZE OVERRIDES
GVNS:	STA	SYMFLG
	ASL
	ASL
	ASL
	ASL
	BCS	GVWO
	ASL
	BCS	GVHB
	ASL
	BCS	GVLB
	BCC	GVWO
GVHB:	ASL
	BCS	GVWO
	LDA	TEMP+1
	STA	TEMP
GVLB:	LDA	#0
	STA	TEMP+1
	LDA	SYMFLG
	AND	#$FC
	STA	SYMFLG
GVWO:	CLC
	RTS

; NOW CONDENSE SOME SPACE BY
; RELEGATING SOME AUTOWRITE
; AND SKIP ROUTINES TO SEPARATE
; PROCEDURES

; --------------------------------
; PREPARE SUPPORT POINTER
SETPTR:	PHA
	CLC
	LDA	BINLEN
	ADC	BINBUF
	STA	TABLE
	LDA	#0
	ADC	BINBUF+1
	STA	TABLE+1
	PLA
	RTS

; --------------------------------
; FILL BINARY BUFFER WITH A
WBINA:	DEY
	BMI	WBINA2
	JSR	SETPTR
WBINA1:	STA	(TABLE),Y
	INC	BINLEN
	DEY
	BPL	WBINA1
WBINA2:	RTS

; --------------------------------
; WRITE ARBITRARY BUFFER TO
; BINARY BUFFER
WBINX:	DEY
	BMI	WBINA2
	JSR	SETPTR
	LDA	0,X
	STA	TEMP
	LDA	1,X
	STA	TEMP+1
WBINX1:	LDA	(TEMP),Y
	STA	(TABLE),Y
	INC	BINLEN
	DEY
	BPL	WBINX1
	RTS

; --------------------------------
; 16-BIT NEGATION
WNEG:	PHA
	SEC
	LDA	#0
	SBC	0,X
	STA	0,X
	LDA	#0
	SBC	1,X
	STA	1,X
	PLA
	CLC
	RTS

; --------------------------------
; ADD ARBITRARY VALUE TO IMM
IADD:	PHA
	CLC
	LDA	IMM
	ADC	0,X
	STA	IMM
	LDA	IMM+1
	ADC	1,X
	STA	IMM+1
	PLA
	CLC
	RTS

; --------------------------------
; SIGN EXTEND
SGNX:	PHA
	LDA	0,X
	ASL	A
	LDA	#0
	ADC	#$FF
	EOR	#$FF
	STA	1,X
	PLA
	CLC
	RTS

; --------------------------------
; READ ONE BYTE FROM BINARY BUFFER
RDBIN:	STY	YSAVE
	LDY	BINLEN
	INC	BINLEN
	LDA	(BINBUF),Y
	LDY	YSAVE
	RTS

; --------------------------------
; CHECK VALUE FOR SYMBOL AND
; WRITE SYMBOL IF DETECTED
WSYMA:	LDA	#0
	STA	XSAVE
	LDX	#SYM
	JSR	SDEF
	BEQ	WSYMA1

; TRY SYMBOL-1
	LDX	#IMM
	JSR	INC16
	LDA	#$2D
	STA	XSAVE
	LDX	#SYM
	JSR	SDEF
	BEQ	WSYMA1

; TRY SYMBOL+1
	LDA	#2
	LDX	#IMM
	JSR	ADDA
	LDA	#$2B
	STA	XSAVE
	LDX	#SYM
	JSR	SDEF
	BNE	WSYMA3
WSYMA1:	JSR	WRM
	LDY	YSAVE

; IF THERE'S A SIGN CHARACTER
; IN X, WRITE SIGN AND 1
	LDA	XSAVE
	BEQ	WSYMA2
	STA	(TXTBUF),Y
	INY
	LDA	#$31
	STA	(TXTBUF),Y
	INY
WSYMA2:	CLC
	RTS

; RESTORE ORIGINAL VALUE
WSYMA3:	LDY	YSAVE
	LDX	#IMM

; --------------------------------
; CONSTANT TIME 16-BIT INCREMENT
INC16:	SEC
	LDA	0,X
	ADC	#0
	STA	0,X
	LDA	1,X
	ADC	#0
	STA	1,X
	SEC
	RTS

; --------------------------------
; WRITE TABLE TO TXTBUF
WRM:	STY	YSAVE
	CLC
	TYA
	ADC	TXTBUF
	STA	TEMP
	LDA	#0
	TAY
	ADC	TXTBUF+1
	STA	TEMP+1
WRM1:	LDA	(TABLE),Y
	STA	(TEMP),Y
	INY
	CMP	#$20
	BCS	WRM1
	DEY
	TYA
	ADC	YSAVE
	TAY
	RTS

; --------------------------------
; SKIP TO NEXT RECORD
SKPDAT:	LDA	#4
	LDX	#TABLE
	JSR	ADDA
	LDX	#TEMP

; --------------------------------
; CONSTANT TIME 16-BIT DECREMENT
DEC16:	CLC
	LDA	0,X
	SBC	#0
	STA	0,X
	LDA	1,X
	SBC	#0
	STA	1,X
	RTS

; --------------------------------
; CHECK IF PC IS WITHIN EXISTING
; RECORD BOUNDARIES
CHKDAT:	LDA	PC+1
	LDY	#1

; LOWER BOUNDARY
	CMP	(TABLE),Y
	BNE	CHKDA1
	LDA	PC
	DEY
	CMP	(TABLE),Y
CHKDA1:	BCC	CHKDA2
	LDY	#3
	LDA	(TABLE),Y

; UPPER BOUNDARY
	CMP	PC+1
	BNE	CHKDA2
	DEY
	LDA	(TABLE),Y
	CMP	PC
CHKDA2:	RTS

; --------------------------------
; PREPARE DATA MAP BUFFER POINTER
PRPDAT:	LDA	FUNC
	AND	#2
	BEQ	PRPDA0
	LDA	MAPBUF
	STA	TABLE
	LDA	MAPBUF+1
	STA	TABLE+1

; PREPARE COUNTER ALSO
	LDY	#0
	LDA	(TABLE),Y
	INY
	STA	TEMP
	LDA	(TABLE),Y
	INY
	STA	TEMP+1
PRPDA0:	RTS

; --------------------------------
; DFS DIRECTIVE
SETDFS:	JSR	RE
	LDX	#USIZE
	JSR	ADDI

; --------------------------------
; STORE DATA AREA ADDRESS
STDAT:	JSR	PRPDAT
	BEQ	STDAT4
STDAT1:	JSR	SKPDAT
	BMI	STDAT3

; CHECK IF PC WITHIN RECORD BOUNDS
	JSR	CHKDAT
	BCC	STDAT1

; CHECK IF DATA AREA FITS
; ENTIRELY
	LDA	PC
	STA	TEMP2
	LDA	PC+1
	STA	TEMP2+1
	LDX	#TEMP2
	JSR	ADDI
	LDY	#3
	LDA	TEMP2+1
	CMP	(TABLE),Y
	BNE	STDAT2
	DEY
	LDA	TEMP2
	CMP	(TABLE),Y
STDAT2:	BCC	STDAT4
	BEQ	STDAT4

; EXTEND RECORD LENGTH AND QUIT
	STA	(TABLE),Y
	INY
	LDA	TEMP2+1
	STA	(TABLE),Y
	CLC
	BCC	STDAT4

; STORE NEW RECORD
STDAT3:	LDY	#3
	LDA	IMM+1
	STA	(TABLE),Y
	DEY
	LDA	IMM
	STA	(TABLE),Y
	DEY
	LDA	PC+1
	STA	(TABLE),Y
	DEY
	LDA	PC
	STA	(TABLE),Y
	TYA
	SEC
	ADC	(MAPBUF),Y
	STA	(MAPBUF),Y
	TYA
	INY
	ADC	(MAPBUF),Y
	STA	(MAPBUF),Y

; ADVANCE PC
STDAT4:	LDX	#PC

; --------------------------------
; ADD IMM TO ARBITRARY VALUE
ADDI:	PHA
	CLC
	LDA	IMM
	ADC	0,X
	STA	0,X
	LDA	IMM+1
	ADC	1,X
	STA	1,X
	PLA
	CLC
	RTS

; --------------------------------
; SCAN FOR DATA AREA ADDRESS
LDDAT:	JSR	PRPDAT
	BEQ	LDDAT2
LDDAT1:	JSR	SKPDAT
	BMI	LDDAT2

; CHECK IF PC WITHIN RECORD BOUNDS
	JSR	CHKDAT
	BCC	LDDAT1
	CLC
	RTS
LDDAT2:	SEC
	RTS
