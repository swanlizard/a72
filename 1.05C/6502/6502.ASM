; --------------------------------
; 6502-SPECIFIC LINE ASSEMBLER
ASMCMD:	CPY	#3
	BNE	ASCMEN

; 6502 MNEMONICS ARE ALL
; 3 CHARACTERS LONG
	LDA	#0
	STA	TABLE
	STA	TABLE+1
	DEY
CM1:	LDX	#5
	LDA	(TXTBUF),Y
	SEC
	SBC	#$40

; SQUEEZE IT DOWN TO 5 BITS PER
; CHARACTER
CM2:	ROR	A
	ROR	TABLE+1
	ROR	TABLE
	DEX
	BNE	CM2
	DEY
	BPL	CM1
	LDA	TABLE
	LDX	TABLE+1

; 64 ENTRIES IN THE MNEMONIC TABLE
	LDY	#$40
RM:	DEY
	BMI	ASCMDR
	CPX	MNEML,Y
	BNE	RM
	CMP	MNEMR,Y
	BNE	RM

; SAVE DETECTED INDEX AND SKIP
; MNEMONIC
	TYA
	PHA
	LDA	#3
	LDX	#TXTBUF
	JSR	ADDA

; READ ADDRESSING MODE
	JSR	RA

; GET OPCODE VIA ADDRESSING MODE
; AND INDEX
	PLA
	STA	XSAVE
	JSR	SCAN

; ADDRESSING MODE FLAGS ALSO
; ENCODE LENGTH
	LDA	FLAGS
	AND	#3
	STA	BINLEN
	LDX	#PC
	JSR	ADDA
	LDY	#0
	LDA	OPCODE
	STA	(BINBUF),Y
	INY
	LDA	IMM
	STA	(BINBUF),Y
	INY
	LDA	IMM+1
	STA	(BINBUF),Y
	LDA	#0
ASCMEN:	RTS

; CHECK FOR DIRECTIVE
ASCMDR:	LDY	#8
RM2:	DEY
	BMI	ASCMEN
	CPX	DIRML,Y
	BNE	RM2
	CMP	DIRMR,Y
	BNE	RM2
	STY	OPCODE
	LDA	#3
	LDX	#TXTBUF
	JSR	ADDA
	JSR	HDLDIR
	LDA	#0
	RTS

; SYNTAX ERROR
ASCMER:	LDA	#1
	JMP	FAIL

; --------------------------------
; WRAPPER FOR INDIRECT CALL
HDLDIR:	LDA	AHDLH,Y
	PHA
	LDA	AHDLL,Y
	PHA
	PHP
	RTI

; --------------------------------
; DETERMINE OPCODE VIA BRUTE FORCE
SCAN:	LDA	#0
	STA	OPCODE
SCAN1:	LDA	OPCODE

; EVERY ------11 OPCODE IS BAD,
; SO GO AHEAD AND SKIP
	AND	#3
	CMP	#3
	BEQ	SCAN3

; IT GOES THROUGH ALL OPCODES ONE
; BY ONE AND DECODING THEM WITH
; MNEM TO DETERMINE WHETHER THEY
; FIT THE SPECIFIED MNEMONIC INDEX
; AND ADDRESSING MODE
	LDA	OPCODE
	JSR	MNEM
	STY	YSAVE
	LDY	XSAVE

; MNEMONIC MATCHES?
	LDA	MNEML,Y
	CMP	MNEML,X
	BNE	SCAN3
	LDA	MNEMR,Y
	CMP	MNEMR,X
	BNE	SCAN3
	LDX	ADDR
	LDY	YSAVE
	LDA	OPCODE

; ADDRESSING MODE MATCHES?
	CPY	ADDR
	BEQ	SCAN6

; ADDRESS SPECIAL CASES
	CMP	#$4C
	BEQ	SCAN4
	CMP	#$20
	BEQ	SCAN4
	CPY	#$09
	BEQ	SCAN7
	CPY	#$0A
	BEQ	SCAN2
	CPY	#$0C
	BEQ	SCAN8
	CPX	#$0D
	BNE	SCAN3
	CPY	#$06
	BEQ	SCAN5
SCAN2:	CPX	#$08
	BEQ	SCAN6
SCAN3:	INC	OPCODE
	BNE	SCAN1

; INVALID ADDRESSING MODE ERROR
ERR2:	LDA	#2
	JMP	FAIL

; SUPPOSE A CALL OR JUMP GOT AN
; ADDRESS THAT WAS INTERPRETED
; AS A BYTE SIZE VALUE
SCAN4:	CPX	#1
	BNE	SCAN3

; Y INDEXED DIRECT MUST BE WORD
; SIZED
SCAN5:	LDA	#3
	STA	FLAGS
SCAN6:	RTS

; INVALID ADDRESSING MODE ADDED
; FOR SINGLE BYTE DFBS FOR DEBUG
; PURPOSES
SCAN7:	CPX	#1
	BNE	ERR2

; THE OPERAND IS NOW THE OPCODE
	STX	FLAGS
	LDA	IMM
	STA	OPCODE
	RTS

; RELATIVE BRANCHES HAVE THEIR
; OWN LITTLE SPECIAL HANDLER
SCAN8:	CLC
	LDA	IMM
	SBC	PC
	STA	IMM
	LDA	IMM+1
	SBC	PC
	STA	IMM+1
	LDX	#IMM
	JSR	DEC16
	LDA	#2
	STA	FLAGS
	JSR	AA
	BEQ	SCAN6

; RELATIVE JUMP OUT OF RANGE ERROR
	LDA	#5
	JMP	FAIL

; --------------------------------
; DIRECTIVES ARE HANDLED
; DIFFERENTLY, SO OPCODE MUST
; BE MANUALLY SET
D5:	LDA	#$FF
	JMP	FAIL
D6:	LDA	#4
	SEC
	SBC	OPCODE
	STA	OPCODE
	JMP	SETINC

; --------------------------------
; READ ARGUMENTS AND DETERMINE
; ADDRESSING MODE
RA:	LDA	#1
	STA	FLAGS
	LDX	#5
RALFT:	JSR	CC
	BEQ	RAADJ

; ANYTHING OVER ONE CHARACTER IS
; FOR SURE NOT APPLICABLE
	CPY	#1
	BNE	RAVAL
	JSR	RDCHR

; ONLY THREE DIFFERENT CHARACTERS
; ARE APPLICABLE BEFORE A CONSTANT
	CPX	#3
	BCS	RALFT

; ADD SIZE OF THE OPERAND
RAVAL:	INC	FLAGS
	JSR	RE
	LDX	#2

; ADJUST SIZE OF OPERAND IF WORD
	LDA	#$13
	BIT	SYMFLG
	BNE	RAWORD
	LDA	IMM+1
	BEQ	RARGT
RAWORD:	INC	FLAGS

; READ THE REST OF APPLICABLE
; CHARACTERS
RARGT:	JSR	CC
	BEQ	RAADJ
	CPY	#1
	BNE	RAERR
	JSR	RDCHR
	BPL	RARGT

; SOME VALUES ARE FLAGGED AS
; WORD SIZED AND END UP CAUSING
; WORD SIZE ADJUSTMENT ON FLAGS;
; DOUBLE CHECK THOSE VALUES
RAADJ:	LDA	FLAGS
	CMP	#$3B
	BEQ	RASIZT
	CMP	#$2F
	BEQ	RASIZT
	CMP	#$43
	BEQ	RASIZT

; ON THE OTHER HAND, CALLS OR
; JUMPS MAY END UP WITH A VALUE
; FLAGGED AS BYTE-SIZED--ADJUST
; ACCORDINGLY
	CMP	#$2A
	BNE	RAFLAG
	ADC	#0
	BNE	RAFLAG

; ONLY BOTHER CHECKING VALUE
; SIZE IF MODE 2 ACTIVE
RASIZT:	LDA	FUNC
	AND	#2
	BEQ	RABYTE
	LDA	IMM+1
	BEQ	RABYTE
	LDX	#IMM
	JSR	AA
	BEQ	RABYTE

; CONSTANT TOO LARGE ERROR
	LDA	#7
	JMP	FAIL
RABYTE:	LDA	FLAGS
	AND	#$FE
RAFLAG:	STA	FLAGS

; FIND MODE INDEX OR DIE TRYING
	LDX	#$0D
RACHK:	CMP	MODE,X
	BEQ	RAEND
	DEX
	BPL	RACHK

; INVALID ADDRESSING MODE ERROR
	LDA	#2
	JMP	FAIL
RAEND:	STX	ADDR
	RTS

; SYNTAX ERROR
RAERR:	LDA	#1
	JMP	FAIL

; --------------------------------
; SCAN FOR APPLICABLE ADDRESSING
; MODE CHARACTERS
RDCHR:	PHA
	LDA	TXTBUF
	STA	TABLE
	LDA	TXTBUF+1
	STA	TABLE+1
	PLA

; CHECK FIRST CHARACTER AND
; ADVANCE PAST
	CMP	CHAR1,X
	BNE	RDCHR5
	INC	TXTBUF
	BNE	RDCHR1
	INC	TXTBUF+1

; CHECK IF SECOND CHARACTER
; OPTIONAL
RDCHR1:	LDA	CHAR2,X
	BEQ	RDCHR3
	JSR	CC
	BNE	RDCHR2

; MISSING OPERAND ERROR
	LDA	#8
	JMP	FAIL

; CHECK SECOND CHARACTER AND
; ADVANCE PAST
RDCHR2:	CMP	CHAR2,X
	BNE	RDCHR5
	INC	TXTBUF
	BNE	RDCHR3
	INC	TXTBUF+1

; SAVE NEW POSITION
RDCHR3:	LDA	TXTBUF
	STA	TABLE
	LDA	TXTBUF+1
	STA	TABLE+1
	STX	XSAVE

; ROTATE FLAG INTO POSITION
; AND APPLY
	LDA	#2
RDCHR4:	ASL
	DEX
	BPL	RDCHR4
	LDX	XSAVE
	ORA	FLAGS
	STA	FLAGS
RDCHR5:	LDA	TABLE
	STA	TXTBUF
	LDA	TABLE+1
	STA	TXTBUF+1
	DEX
	RTS

; --------------------------------
; READ NUMERIC CONSTANT
RNC:	LDX	#5

; CHECK NUMBER BASE SIGIL
	CMP	#$24
	BEQ	RNC16
	CMP	#$25
	BEQ	RNC2
	CMP	#$30
	BCC	RNC0
	CMP	#$3A
	BCC	RNC10
	CMP	#$40
	BEQ	RNC8
RNC0:	SEC
	RTS

; ROTATION COUNT SLIDE
RNC2:	DEX
RNC4:	DEX
RNC8:	DEX
RNC16:	DEX

; SKIP PAST SIGIL
	INC	TXTBUF
	BNE	RNC1
	INC	TXTBUF+1
RNC1:	JSR	CC
	BEQ	RNM8
RNC10:	JSR	RN
	BNE	RNC0
	CLC
	RTS

; MISSING OPERAND ERROR
RNM8:	LDA	#8
	JMP	FAIL

; --------------------------------
; SCAN FOR LOW/HIGH BYTE OVERRIDE
RNM:	LDX	#4
	CMP	#$3C
	BEQ	RNM1
	LDX	#8
	CMP	#$3E
	BEQ	RNM1
	LDX	#10
	CMP	#$21
	BEQ	RNM1
	SEC
	RTS
RNM1:	TXA
	ORA	SYMFLG
	STA	SYMFLG
	INC	TXTBUF
	BNE	RNM2
	INC	TXTBUF+1
RNM2:	JSR	CC
	BEQ	RNM8
	CLC
	RTS

; --------------------------------
; DISASSEMBLE ONE INSTRUCTION
DISASM:	STY	YSAVE
	JSR	LDDAT

; WRITE DATA BYTE AS DFB
	LDX	#$10
	LDY	#9
	BCC	WMN
	LDY	YSAVE

; IF NOT DATA, DISASSEMBLE
	JSR	RDBIN
	STA	IMM
	JSR	RDBIN
	STA	IMM+1

; GET MNEMONIC INDEX IN BX AND
; ADDRESSING MODE IN AL
	LDA	OPCODE
	JSR	MNEM
WMN:	STY	ADDR

; DECODE 5-BIT STORED MNEMONIC
	LDA	MNEML,X
	STA	TABLE+1
	LDA	MNEMR,X
	STA	TABLE
	LDY	#3
WMN1:	LDX	#5
WMN2:	ROL	TABLE
	ROL	TABLE+1
	ROL	A
	DEX
	BNE	WMN2
	AND	#$1F
	CLC
	ADC	#$40
	PHA
	DEY
	BNE	WMN1
	LDA	YSAVE
	CLC
	ADC	#3
	STA	YSAVE
	LDY	YSAVE
	DEY
	LDX	#3
WMN3:	PHA
	STA	(TXTBUF),Y
	DEY
	DEX
	BNE	WMN3
	LDY	YSAVE
	LDX	ADDR

; GET ADDRESSING MODE FLAGS AND
; WRITE OUT INSTRUCTION OPERAND
	LDA	MODE,X
	CMP	#1
	BEQ	UNRAE
	PHA
	LDA	#9
	STA	(TXTBUF),Y
	INY
	PLA
	CMP	#$55
	BEQ	INVD
	CMP	#$AA
	BEQ	RELD
	STA	FLAGS
	AND	#3
	STA	BINLEN
	LDX	#3

; OPPOSITE OF RA
UNRAA:	ASL	FLAGS
	BCC	UNRAB
	LDA	CHAR1,X
	STA	(TXTBUF),Y
	INY
	LDA	CHAR2,X
	BEQ	UNRAB
	STA	(TXTBUF),Y
	INY
UNRAB:	CPX	#3
	BNE	UNRAD
	LDA	BINLEN
	CMP	#2
	BCC	UNRAD
	CMP	#3
	BCC	UNRAC
	JSR	RELD0
	BCC	UNRAD
UNRAC:	LDA	#0
	STA	SYMFLG
	JSR	WSYMA
	BCC	UNRAD
	JSR	INVD0
UNRAD:	DEX
	BPL	UNRAA
UNRAE:	RET

; ILLEGAL OPCODES JUST WRITE OUT
; THEIR OPCODE AS A DFB
INVD:	LDA	#1
	STA	BINLEN
	LDA	OPCODE
	STA	IMM
INVD0:	LDA	#$24
	STA	(TXTBUF),Y
	INY
	LDA	IMM
	JMP	HALX

; RELATIVE BRANCHES ARE A SPECIAL
; CASE SCENARIO
RELD:	LDA	#2
	STA	BINLEN
	LDX	#IMM
	JSR	SGNX
	JSR	ADDA
	LDX	#PC
	JSR	IADD
RELD0:	LDA	#$0C
	STA	SYMFLG
	JSR	WSYMA
	BCS	RELD1
	RTS
RELD1:	LDA	#$24
	STA	(TXTBUF),Y
	INY
	LDA	IMM+1
	JSR	HALX
	LDA	IMM
	JMP	HALX

; --------------------------------
; EXTRACT INSTRUCTION PARAMETERS
; FROM OPCODE
MNEM:	PHA
	TAY

; ------10 IS POTENTIALLY A BIT
; SHIFT OPERATION
	LSR	A
	BCC	ASLD

; ------11 IS ILLEGAL
	ROR	A
	BCS	INVI

; CANNOT STA IMMEDIATE
	CMP	#$A2
	BEQ	INVI

; EVERYTHING ------01 OTHER THAN
; STA IS FULLY REGULAR AND FOLLOWS
; A SET PATTERN
	AND	#$87

; GET ADDRESSING MODE INDEX FROM
; TABLE.  ONLY 128 INSTRUCTIONS
; NEED BE ENCODED: EVERY OTHER
; INSTRUCTION IS EITHER ILLEGAL
; ('11) OR REGULAR ENOUGH THAT IT
; NEEDS NO DECODING ('01)
ASLD:	LSR	A
	TAX
	LDA	DGRP,X

; TABLE IS STORED AS NIBBLES, AND
; ODD INDICES MUST BE SHIFTED INTO
; POSITION
	BCS	ODDD
	LSR	A
	LSR	A
	LSR	A
	LSR	A
ODDD:	AND	#$0F
	CMP	#9
	BNE	GMNM

; ILLEGAL INSTRUCTIONS JUST GET
; DFB DIRECTIVE
INVI:	LDY	#9
	LDX	#$10
	PLA
	RTS

; CALCULATE MNEMONIC INDEX
GMNM:	PHA
	TYA
	AND	#$8F
	TAX
	TYA
	LDY	#3

; TXA GROUP HAS A SPECIFIC PATTERN
	CMP	#$8A
	BEQ	TXAD

; LOOPBACK FOR '100 GROUP
DFBD:	LSR	A
	BCC	TXAD

; FALL THROUGH TO REGULAR '01
	LSR	A

; LOOPBACK FOR '000 GROUP
BRKD:	LSR	A
	ORA	#$20
	DEY
	BNE	BRKD
	INY
TXAD:	DEY
	BNE	DFBD
	TAX
	PLA
	TAY
	PLA
	RTS

; --------------------------------
; DIRECTIVE HANDLERS
AHDLL:	DFB	<SETDFS,<SETDFB
	DFB	<SETDFB,<SETEQU
	DFB	<SETORG,<D5
	DFB	<D6,<D6
AHDLH:	DFB	>SETDFS,>SETDFB
	DFB	>SETDFB,>SETEQU
	DFB	>SETORG,>D5
	DFB	>D6,>D6

; --------------------------------
; DIRECTIVE MNEMONICS
DIRML:	DFB	$21,$21,$21,$2C
	DFB	$7C,$2B,$0C,$12
DIRMR:	DFB	$A6,$84,$AE,$6A
	DFB	$8E,$88,$20,$5C

; --------------------------------
; ADDRESSING MODE CHARACTERS
CHAR1:	DFB	$2C,$29,$2C
	DFB	$28,$23,$41
CHAR2:	DFB	$59,$00,$58
	DFB	$00,$00,$00

; --------------------------------
; ADDRESSING MODE FLAGS
MODE:	DFB	$3A,$02,$42,$03
	DFB	$2E,$12,$07,$13
	DFB	$01,$55,$81,$2B
	DFB	$AA,$06H

; --------------------------------
; ADDRESSING MODE INDICES BY
; OPCODE, BARRING ILLEGAL '11 AND
; FULLY REGULAR '01 SETS
DGRP:	DFB	$89,$91,$8A,$93
	DFB	$C9,$95,$89,$97
	DFB	$39,$11,$8A,$33
	DFB	$C9,$95,$89,$97
	DFB	$89,$91,$8A,$33
	DFB	$C9,$95,$89,$97
	DFB	$89,$91,$8A,$B3
	DFB	$C9,$95,$89,$97
	DFB	$99,$11,$88,$33
	DFB	$C9,$5D,$88,$99
	DFB	$22,$11,$88,$33
	DFB	$C9,$5D,$88,$76
	DFB	$29,$11,$88,$33
	DFB	$C9,$95,$89,$97
	DFB	$29,$11,$88,$33
	DFB	$C9,$95,$89,$97
	DFB	$01,$23,$45,$67

; --------------------------------
; MNEMONICS ARRANGED BY GROUP
; 000, 100, 1010, 10, 01
MNEML:	DFB	$14,$82,$14,$1B
	DFB	$54,$83,$13,$99
	DFB	$95,$82,$15,$1B
	DFB	$95,$83,$15,$99
	DFB	$21,$21,$10,$A6
	DFB	$61,$A0,$10,$1B
	DFB	$1C,$4B,$13,$1B
	DFB	$1C,$4B,$11,$99
	DFB	$21,$12,$53,$53
	DFB	$9D,$61,$1C,$1C
	DFB	$A6,$A6,$A0,$A4
	DFB	$21,$21,$73,$21
	DFB	$0C,$93,$64,$93
	DFB	$9D,$61,$21,$4B
	DFB	$7C,$0B,$2B,$09
	DFB	$9D,$61,$1B,$98
MNEMR:	DFB	$96,$20,$18,$06
	DFB	$E4,$20,$52,$46
	DFB	$12,$02,$86,$12
	DFB	$26,$02,$A6,$52
	DFB	$84,$72,$C6,$42
	DFB	$32,$72,$E6,$2C
	DFB	$32,$B2,$8A,$08
	DFB	$30,$B0,$62,$48
	DFB	$84,$68,$60,$60
	DFB	$32,$32,$32,$30
	DFB	$02,$26,$70,$F0
	DFB	$70,$84,$E0,$84
	DFB	$D8,$D8,$E4,$E4
	DFB	$30,$30,$46,$86
	DFB	$82,$88,$E4,$06
	DFB	$02,$02,$60,$86
