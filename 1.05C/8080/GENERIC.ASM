; --------------------------------
; ASSEMBLE ONE LINE
ASM:	XCHG
	LXI	H,0
	DAD	SP

; SAVE STACK SO EVERY ERROR
; CAN RETURN HERE REGARDLESS OF
; STACK CONTENTS
	SHLD	STK
	XCHG
	MVI	A,0
	STA	BINLEN
	LHLD	TXTBUF
	LDA	FUNC
	RLC
	JNC	ASMLIN
	STA	TXTLEN

; WRITE LABEL IF SYMBOLS ARE TO
; BE READ
	LDA	FUNC
	ANI	2
	JZ	NOSYM
	LDA	PC
	STA	IMM
	LDA	PC+1
	STA	IMM+1
	MVI	A,0CH
	STA	SYMFLG
	LXI	D,SYMBS
	CALL	SDEF
	JNZ	NOSYM
	PUSH	D
WSYML:	LDAX	D
	INX	D
	CPI	21H
	JNC	WSYML
	POP	D

; WRITE SYMBOL IF IT IS NOT
; AN EQUATE
	ANI	2
	JNZ	NOSYM
	CALL	WRM
	MVI	M,3AH
	INX	H
NOSYM:	CALL	RDBIN
	STA	OPCODE
	CALL	DISASM
	MVI	M,0DH
	INX	H
	MVI	M,0AH
	INX	H
	MOV	A,L
	LHLD	TXTBUF
	SUB	L
	STA	TXTLEN
	MVI	D,0
	LDA	BINLEN
	MOV	E,A
	LHLD	PC
	DAD	D
	SHLD	PC
	STC
	CMC
	RET
ASMLBL:	CALL	LBL

; RESET STACK JUST IN CASE WE
; GOT BACK HERE FROM SOME OR
; OTHER ODD PLACE
ASMLIN:	XCHG
	LHLD	STK
	SPHL
	XCHG
	CALL	CCH
	JZ	SETEQ0

; EQUAL SIGN WORKS LIKE AN EQU
	CPI	3DH
	JZ	ASMEQU

; SET PROGRAM COUNTER BY CHARACTER
	CPI	PCCHAR
	JZ	ASMORG
	CALL	ASMCMD
	JNZ	ASMLBL
	CALL	CCH
	JZ	SETEQ0

; CHARACTERS PAST END OF LINE
; ERROR
	MVI	A,9
	JMP	FAIL
ASMEQU:	INX	H

; --------------------------------
; EQU DIRECTIVE OR EQUAL SIGN
SETEQU:	LDA	FUNC
	ANI	3
	JZ	SETEQ0
	CALL	RE
	XCHG
	LHLD	SYMPTR
	MOV	A,M
	ORI	2
	MOV	M,A
	INX	H
	LDA	IMM
	MOV	M,A
	INX	H
	LDA	IMM+1
	MOV	M,A
	XCHG
SETEQ0:	STC
	CMC
	RET
ASMORG:	INX	H
	CALL	CCH
	JZ	ASMOER
	CPI	3DH
	JNZ	ASMOER
	INX	H

; --------------------------------
; ORG DIRECTIVE
SETORG:	CALL	RE
	PUSH	H
	LHLD	PC
	XCHG
	LHLD	IMM
	SHLD	PC

; CHECK FOR START OF PROGRAM
	LDA	VORG
	CMP	E
	JNZ	SETOR1
	LDA	VORG+1
	CMP	D
	JNZ	SETOR1

; SET LOAD ADDRESS AT
; PROGRAM START
	XCHG
	LXI	H,SYMBS
	INX	H
	INX	H
	INX	H
	MOV	M,E
	INX	H
	MOV	M,D
	POP	H
	STC
	CMC
	RET

; IF NEW ADDRESS IS AHEAD,
; DEFINE AS EMPTY SPACE
SETOR1:	LDA	IMM
	SUB	E
	STA	IMM
	LDA	IMM+1
	SBB	D
	STA	IMM+1
	JM	SETOR2
	LHLD	IMM
	XCHG
	LHLD	USIZE
	DAD	D
	SHLD	USIZE
SETOR2:	POP	H
	STC
	CMC
	RET

; SYNTAX ERROR
ASMOER:	MVI	A,1
	JMP	FAIL

; --------------------------------
; SCAN FOR TOKENS AT TXTBUF
; SET HL TO FIRST TOKEN
; LOCATION, BC TO LENGTH, A TO
; FIRST CHAR
CCH:	PUSH	D
	LXI	B,0
CCM:	MOV	E,L
	MOV	D,H
	DAD	B
	XCHG
	LDAX	D
	CPI	0
	JZ	CCT
	CPI	0DH
	JZ	CCT
	CPI	21H
	JC	CCK
	CPI	22H
	JZ	CCQ
	CPI	27H
	JZ	CCQ
	CPI	30H
	JC	CCS
	CPI	3AH
	JC	CCL
	CPI	3BH
	JZ	CCT
	CPI	41H
	JC	CCS
	CPI	5BH
	JC	CCL
	CPI	5FH
	JZ	CCL
	CPI	61H
	JC	CCS
	CPI	7BH
	JNC	CCS

; CONVERT NORMAL LETTER
; TO UPPERCASE
	ANI	0DFH
	STAX	D

; INCREMENT TOKEN LENGTH
CCL:	INX	B
	JMP	CCM

; IF TOKEN EXISTS, ABORT AND
; RETURN TOKEN, OTHERWISE
; SCAN UNTIL NEXT MATCHING
; QUOTE AND RETURN QUOTED
; TEXT AS TOKEN
CCQ:	MOV	A,B
	ADD	C
	JNZ	CCE
	MOV	A,M
CCW:	INX	B
	MOV	E,L
	MOV	D,H
	DAD	B
	CMP	M
	XCHG
	JNZ	CCW
	INX	B

; ABORT AND RETURN FIRST
; CHARACTER ON LINE AND
; SET ZERO FLAG
CCT:	MOV	A,B
	ADD	C
CCE:	MOV	A,M
	POP	D
	RET

; IF THERE IS ALREADY A TOKEN
; ABORT AND RETURN EXISTING
; TOKEN, OTHERWISE RETURN
; SPECIAL CHARACTER
CCS:	MOV	A,B
	ADD	C
	JNZ	CCE
	INX	B
	JMP	CCT

; IF THERE IS A TOKEN, ABORT
; AND RETURN IT, OTHERWISE
; SKIP SPACE
CCK:	MOV	A,B
	ADD	C
	JNZ	CCE
	INX	H
	JMP	CCM

; --------------------------------
; TEST IF 16-BIT SIGNED NUMBER
; CAN UNAMBIGUOUSLY FIT WITHIN
; 8 BITS
AA:	MOV	A,C
	ANI	80H
	MOV	A,B
	JNZ	AA1

; IF SIGN BIT IS NOT SET ON
; LOWER BYTE, UPPER BYTE MUST
; BE ZERO
	CPI	0
	RET

; IF SIGN BIT IS SET ON LOWER
; BYTE, UPPER BYTE MUST BE FF
AA1:	CPI	0FFH
	RET

; --------------------------------
; SCAN SYMBOL TABLE FOR TOKEN
; AND RETURN DEFINITION IF FOUND
SL:	PUSH	B

; GET SYMBOL COUNT AND SET UP
; TEMPORARY COUNTER
	INX	D
	LDAX	D
	MOV	B,A
	DCX	D
	LDAX	D
	MOV	C,A

; ADVANCE TABLE POINTER, ADD
; 2 BYTES FOR DEFINITION
SL1:	INX	D
	INX	D

; DECREMENT COUNTER
	DCX	B
	MOV	A,B
	ORA	A
	JM	SL6

; LENGTH IS ON TOP OF THE STACK
	XTHL
	MOV	A,L
	XTHL
	PUSH	B
	PUSH	H
	MOV	C,A

; CHECK ENTRY AGAINST SYMBOL
SL2:	LDAX	D
	CMP	M
	JNZ	SL3
	INX	H
	INX	D
	DCR	C
	JNZ	SL2
	POP	H
	POP	B
	LDAX	D

; IF EVERYTHING MATCHES BUT
; ENTRY ISN'T OVER AFTER TOKEN
; IS, REFUTE MATCH
	CPI	21H
	JNC	SL5

; RESTORE LENGTH
	POP	B
	PUSH	H

; USE BC BEFORE REPURPOSING IT
	DAD	B
	INX	H
	MOV	C,M
	INX	H
	MOV	B,M

; SET ZERO FLAG TO SIGNAL
; SYMBOL FOUND
	CMP	A
SL6:	POP	H
	RET

; KEEP SCANNING UNTIL TERMINATOR
SL3:	POP	H
	POP	B
SL4:	LDAX	D
	CPI	21H

; INCLUDE TERMINATOR IN COUNT
SL5:	INX	D
	JNC	SL4
	JMP	SL1

; --------------------------------
; SCAN SYMBOL TABLE BY IMM FOR
; DEFINITION, ACCORDING TO
; SYMFLG, AND RETURN SYMBOL
SDEF:	PUSH	H

; GET SYMBOL COUNT AND SET UP
; TEMPORARY COUNTER
	LDAX	D
	INX	D
	MOV	C,A
	LDAX	D
	INX	D
	MOV	B,A
	DCX	B
	INX	D
	XCHG
	JMP	SDEF6

; GET ENTRY LENGTH
SDEF1:	MOV	H,D
	MOV	L,E
SDEF2:	LDAX	D
	INX	D
	CPI	21H
	JNC	SDEF2
	INX	D

; CHECK DEFINITION
	XCHG
	LDA	SYMFLG
	ANI	0CH
	JZ	SDEF4
	CPI	0CH
	JZ	SDEF3
	ANI	8
	JZ	SDEF5

; HIGH BYTE
	LDA	IMM
	CMP	M
	JNZ	SDEF7
	POP	H
	RET

; FULL WORD
SDEF3:	LDA	IMM+1
	CMP	M
	JNZ	SDEF7
	JZ	SDEF5

; SIGNED BYTE
; FALLS THROUGH TO LOW BYTE
SDEF4:	MOV	A,M
	CPI	0
	JZ	SDEF5
	CPI	0FFH
	JNZ	SDEF7
	DCX	H
	MOV	A,M
	ORA	A
	JP	SDEF6
	INX	H

; LOW BYTE
SDEF5:	DCX	H
	LDA	IMM
	CMP	M
	JNZ	SDEF6
	POP	H
	RET
SDEF6:	INX	H
SDEF7:	INX	H
	XCHG

; CHECK COUNTER FOR ZERO AND
; DECREMENT
	DCX	B
	MOV	A,B
	ORA	A
	JP	SDEF1
	POP	H
	RET

; --------------------------------
; STEAL ALLISON'S ALGORITHM
HALX:	PUSH	PSW
	RRC
	RRC
	RRC
	RRC
	CALL	HALL
	POP	PSW
HALL:	ANI	0FH
	ADI	90H
	DAA
	ACI	40H
	DAA
	MOV	M,A
	INX	H
	RET

; --------------------------------
; READ 16-BIT NUMBER IN EITHER
; BINARY, OCTAL, HEX, OR DECIMAL
; AS DEFINED BY ROTATION COUNT
; IN B
RN:	MOV	A,B

; BLANK OUT TEMPORARY STORAGE
	MVI	D,0
	MVI	E,0

; B BETWEEN 1 AND 4 WORKS WITH
; COMMON NUMBER BASES THAT ARE
; POWERS OF 2.  ANYTHING ELSE
; IS CHANGED TO ZERO WHICH WORKS
; WITH DECIMAL
	CPI	5
	JC	RN2
	MVI	B,0
RN1:	MOV	A,B
RN2:	XCHG
	DAD	H
	XCHG

; IF NOTHING IN B, CONTINUE
; PROCESSING AS DECIMAL
	ORA	A
	JZ	RN3
	DCR	A
	JNZ	RN2
RN3:	PUSH	H
	XCHG
	DAD	H
	DAD	H
	DAD	D
	XCHG
	POP	H

; READ ONE DIGIT FROM LINE
	MOV	A,M
	INX	H
	SUI	30H

; ANYTHING BELOW $30 WILL
; UNDERFLOW OUT OF ITS VALID
; DIAPAZON AND WILL NOT PASS THE
; FOLLOWING UPPER BOUNDARY TESTS
	CPI	0AH
	JC	RN4
	SUI	7
	CPI	0FH
	JC	RN4
	JNZ	RN0
RN4:	ADD	E
	MOV	E,A
	MOV	A,D
	ACI	0
	MOV	D,A
	DCR	C
	JNZ	RN1

; IF THE TOKEN IS FULLY
; PROCESSED, BX WILL END UP
; TRIGGERING THE ZERO FLAG.  IF
; EXITED VIA THE EARLIER JUMP,
; THE ZERO FLAG ISN'T SET,
; SIGNALING AN INVALID DIGIT.
RN0:	MVI	B,0
	RET

; --------------------------------
; WRITE 16-BIT NUMBER TO TEXT
; BUFFER AS A NUMERIC CONSTANT
; WITHOUT LEADING ZEROES
; IN BASE SPECIFIED BY E
WN:	MOV	A,E
	CPI	0
	JZ	WDA
	CPI	5
	JNC	WDA
	MVI	A,0
	PUSH	D

; BASES 2, 4, 8, AND 16 CAN
; BE HANDLED WITH SHIFTS
WN1:	PUSH	D
	MVI	D,0
WN2:	STC
	CMC
	MOV	A,B
	RAR
	MOV	B,A
	MOV	A,C
	RAR
	MOV	C,A
	MOV	A,D
	RAR
	MOV	D,A
	DCR	E
	JNZ	WN2
	MOV	A,D
	POP	D

; GET IT BACK INTO POSITION
	PUSH	D
WN3:	RLC
	DCR	E
	JNZ	WN3
	POP	D

; GIVE THANKS TO ALLISON
	ADI	90H
	DAA
	ACI	40H
	DAA
	MOV	M,A
	INX	H

; END WHEN NO MORE MAIN VALUE
	MOV	A,B
	ADD	C
	JNZ	WN1
	RET

; BASE 10 REQUIRES SOME SETUP
WDA:	PUSH	H
	PUSH	H
	CALL	WDA3
	POP	B

; STRIP LEADING ZEROES
	MVI	E,0FFH
	DCX	B
WDA1:	INR	E
	INX	B
	LDAX	B
	CPI	30H
	JZ	WDA1
	MOV	A,E
	POP	D
	ORA	A
	RZ
	XCHG
	MOV	E,A
WDA2:	LDAX	B
	MOV	M,A
	INX	H
	INX	B
	DCR	E
	JNZ	WDA2
	RET

; YOU THOUGHT THAT WAS UGLY?
; GET A LOAD OF THIS!
WDA3:	MOV	D,B
	MOV	E,C
	LXI	B,-10000
	CALL	WDA4
	LXI	B,-1000
	CALL	WDA4
	LXI	B,-100
	CALL	WDA4
	LXI	B,-10
	CALL	WDA4
	LXI	B,-1

; SOME SERIOUS BRUTE FORCE
WDA4:	MVI	A,2FH
	XCHG
WDA5:	INR	A
	DAD	B
	JC	WDA5

; ADD BACK THAT LAST ONE
	STC
	SBB	A
	XRA	B
	MOV	B,A
	SBB	A
	XRA	C
	MOV	C,A
	INX	B
	DAD	B
	XCHG
	MOV	M,A
	INX	H
	RET

; --------------------------------
; ADD SYMBOL TO SYMBOL TABLE
; OR REDEFINE EXISTING SYMBOL
LBL:	CALL	CCH
	LDA	FUNC
	ANI	3
	JZ	ERR3

; PROCESS DETECTED SYMBOL
	LXI	D,SYMBS
	CALL	SL
	JZ	LBL1

; SYMBOL EXISTS, BUT CAN BE
; REDEFINED ON FUNCTION 2
	XCHG
	DAD	B
	XCHG
	LDA	FUNC
	ANI	2
	JNZ	LBL2

; DUPLICATE SYMBOL ERROR
	MVI	A,0AH
	JMP	FAIL

; WRITE SYMBOL TO TABLE
LBL1:	MOV	A,M
	STAX	D
	INX	D
	INX	H
	DCR	C
	JNZ	LBL1
	MVI	A,0
	STAX	D

; INCREASE SYMBOL COUNT
	PUSH	H
	LHLD	SYMBS
	INX	H
	SHLD	SYMBS
	POP	H

; SAVE POINTER TO ENTRY
LBL2:	XCHG
	SHLD	SYMPTR
	INX	H
	XCHG

; GET CURRENT PROGRAM COUNTER
; AND STORE IN TABLE WITH THE
; NEW ENTRY
	LDA	PC
	STAX	D
	INX	D
	LDA	PC+1
	STAX	D

; CHECK FOR COLON OR INSTRUCTION
	CALL	CCH
	JZ	ERR3
	CPI	3AH
	RNZ

; SKIP COLON
	INX	H
	RET

; INVALID INSTRUCTION ERROR
ERR3:	MVI	A,3
	JMP	FAIL

; --------------------------------
; PROCESS DFB/DFW DIRECTIVE
SETDFB:	XCHG
	LHLD	BINBUF
	XCHG
	MVI	A,0
	STA	UDATA
SETDMA:	CALL	CCH
	JZ	ERR8
	CPI	3FH
	JZ	SETDUD

; DEFINED DATA IS DISCOVERED SO
; WRITE ALL PRECEDING UNDEFINED
; DATA TO BUFFER AS ZEROES;
; IF NONE, REP WILL EXECUTE
; ZERO TIMES
	PUSH	PSW
	LDA	UDATA
	CPI	0
	JZ	SETDNU
	PUSH	B
	MOV	C,A
	MVI	A,0
SETDUL:	STAX	D
	INX	D
	DCR	C
	JNZ	SETDUL
	POP	B
SETDNU:	POP	PSW
	CPI	22H
	JZ	SETDQU
	CPI	27H
	JZ	SETDQU
SETDVA:	PUSH	D
	CALL	RE
	POP	D
	LDA	IMM
	STAX	D
	INX	D
	LDA	IMM+1
	STAX	D
	LDA	OPCODE

; STORE ONLY THE NECESSARY
; AMOUNT OF BYTES
	CPI	1
	JZ	SETDCM
	INX	D

; ALREADY HAVE TWO BYTES OF
; VALUE STORED
	SUI	2
	JZ	SETDCM

; VALUES LARGER THAN 16 BITS
; ARE SIGN EXTENDED TO FILL
	MOV	C,A
	LDA	IMM+1
	RAL
	SBB	A
SETDVW:	STAX	D
	INX	D
	DCR	C
	JNZ	SETDVW
	JMP	SETDCM

; IF ANY UNDEFINED DATA IS
; FOUND, ADD IT UP
SETDUD:	LDA	OPCODE
	MOV	C,A
	LDA	UDATA
	ADD	C
	STA	UDATA
	INX	H
	JMP	SETDCM

; QUOTED STRINGS OF LESS THAN 3
; BYTES ARE PROCESSED AS LITERAL
; BINARY CONSTANTS
SETDQU:	LDA	OPCODE
	ADI	2
	CMP	C
	JNC	SETDVA

; WRITE ONLY WHAT IS BETWEEN THE
; QUOTATION MARKS AND SKIP MARKS
	DCR	C
	DCR	C
	INX	H
SETDQL:	MOV	A,M
	STAX	D
	INX	D
	INX	H
	DCR	C
	JNZ	SETDQL
	INX	H

; IF THERE ARE ANY MORE
; CHARACTERS ON THE LINE, THE
; FIRST MUST BE A COMMA
SETDCM:	CALL	CCH
	JZ	SETDEN
	CPI	2CH
	JNZ	ERR1
	INX	H
	JMP	SETDMA

; ADD ANY UNDEFINED DATA TO THE
; ACCUMULATED AMOUNT AND UPDATE
; PC BY THE SAME AMOUNT.  THE
; ASM PROCEDURE WILL UPDATE PC
; BY THE LENGTH OF THE BINARY
; OUTPUT PRODUCED, I.E. HOW FAR
; THE BUFFER HAS BEEN SKIPPED
SETDEN:	PUSH	H
	LDA	UDATA
	MOV	C,A
	MVI	B,0
	LHLD	USIZE
	DAD	B
	SHLD	USIZE
	LXI	H,BINBUF
	MOV	A,E
	SUB	L
	MOV	L,A
	MOV	A,D
	SBB	H
	MOV	H,A
	SHLD	BINLEN
	DAD	B
	SHLD	IMM
	POP	H
	JMP	STDAT

; MISSING OPERAND ERROR
ERR8:	MVI	A,8
	JMP	FAIL

; SYNTAX ERROR
ERR1:	MVI	A,1
	JMP	FAIL

; --------------------------------
; PREPARE FILE NAME FOR
; INCLUDE DIRECTIVE
SETINC:	CALL	CCH
	JZ	ERR8
	CPI	22H
	JZ	SETIN1
	CPI	27H
	JNZ	SETIN2
SETIN1:	INX	H

; IF ENCLOSED IN QUOTES, MUST
; BE AT LEAST 3 CHARACTERS LONG
; INCLUDING THE TWO MARKS
	DCR	C
	JZ	ERR8
	DCR	C
	JZ	ERR8
	JMP	SETEND

; IF NOT IN QUOTES, GET REST
; OF LINE UNTIL FIRST EMPTY
; SPACE OR SEMICOLON
SETIN2:	LXI	B,0
SETIN3:	INX	B
	MOV	E,L
	MOV	D,H
	DAD	B
	XCHG
	LDAX	D
	CPI	3BH
	JZ	SETEND
	CPI	21H
	JNC	SETIN3

; PROCEED DIRECTLY INTO THE
; I/O HANDLER
SETEND:	LDA	OPCODE

; --------------------------------
; ERROR AND I/O HANDLER
FAIL:	PUSH	H
	LHLD	STK
	SPHL
	POP	H

; FIRST RESET STACK TO TOP LEVEL
; CALLER, THE LINE ASSEMBLER
	CPI	5
	JNZ	FAIL0

; ERROR CODE 5 IS RELATIVE JUMP
; OUT OF RANGE; CALCULATE THE
; ABSOLUTE AMOUNT OF BYTES
	LDA	IMM+1
	RAL
	JNC	FAIL1
	RAR
	CMA
	STA	IMM+1
	LDA	IMM
	CMA
	STA	IMM
FAIL1:	LDA	IMM
	SUI	7FH
	STA	IMM
	LDA	IMM+1
	SBI	0
	STA	IMM+1
FAIL0:	STC
	RET

; --------------------------------
; PRIMITIVE EXPRESSION EVALUATOR
RE:	MVI	A,0
	STA	IMM
	STA	IMM+1
	STA	SYMFLG
REA:	CALL	CCH
	JZ	RED

; PREPARE TO SET ARITHMETIC
; OPERATOR FLAGS
	CPI	2BH
	JZ	REC
	CPI	2DH
	JZ	REB

; GV WILL APPLY THE OPERATOR
; AND RESET ITS FLAG
	CALL	GV
	JC	RED

; IF AN IDENTIFIER WAS FOUND,
; GV HAS SET ITS FLAG INSTEAD
	XCHG
	LHLD	IMM
	DAD	B
	SHLD	IMM
	XCHG
	JMP	REA

; USE OF AN OPERATOR WILL RESET
; THE IDENTIFIER FLAG
REB:	LDA	SYMFLG
	XRI	80H
	STA	SYMFLG
REC:	LDA	SYMFLG
	ANI	0BFH
	STA	SYMFLG
	INX	H
	JMP	REA

; CHECK FOR OPERAND TO MAKE
; SURE THERE ARE NO DANGLING
; OPERATORS
RED:	LDA	SYMFLG
	ANI	40H
	JZ	ERR8
	RET

; --------------------------------
; HANDLE ONE NUMERIC CONSTANT
; OR IDENTIFIER AND GET VALUE
GV:	MOV	E,A
	LDA	SYMFLG
	ANI	40H

; CHECK FLAGS IF IDENTIFIER WAS
; ALREADY PROCESSED
	JNZ	GVA
	MOV	A,E
	CPI	PCCHAR
	JZ	GVC
	CPI	22H
	JZ	GVQ
	CPI	27H
	JZ	GVQ

; CHECK SIZE OVERRIDES AND START
; OVER IF THERE ARE ANY
	CALL	RNM
	JZ	GV
	CALL	RDC
	JNC	GVV

; INVALID CHARACTERS MEANS THE
; END OF THE IDENTIFIER
	CPI	40H
	JC	GVA
	LDA	FUNC
	ANI	3
	JNZ	GVL

; ONLY BOTHER READING LABELS
; IF THE FUNCTION IS SPECIFIED
; OTHERWISE JUST GET CURRENT PC
GVC:	DAD	B
	LDA	SYMFLG
	ORI	1
	STA	SYMFLG
	LDA	PC
	MOV	C,A
	LDA	PC+1
	MOV	B,A
	JMP	GVV

; RETURN WITH CARRY MEANS
; UNEXPECTED ENTRY OR END
; OF LINE
GVA:	STC
	RET

; SAVE TWO PLACES PAST FIRST
; QUOTATION MARK
GVQ:	MOV	E,L
	MOV	D,H
	INX	D
	DAD	B
	MOV	A,C
	PUSH	PSW
	LDAX	D
	MOV	C,A
	INX	D
	LDAX	D
	MOV	B,A
	POP	PSW

; 5 CHARACTERS INCLUDING 2
; QUOTES MEANS 3 CHARACTER VALUE
; AND THAT IS EXCESSIVE
	CPI	5
	JNC	GV7

; 2 CHARACTER VALUE MEANS WHAT
; WAS SAVED IS GOOD
	CPI	4
	JNC	GVV

; 0 CHARACTER VALUE CANNOT BE
	CPI	3
	JC	GV8

; 1 CHARACTER MEANS UPPER BYTE
; OF TEMP VALUE MUST BE BLANKED
	MVI	B,0
	JMP	GVV

; CONSTANT TOO LARGE ERROR
GV7:	MVI	A,7
	JMP	FAIL

; MISSING OPERAND ERROR
GV8:	MVI	A,8
	JMP	FAIL

; PROCESS SYMBOL REFERENCE
GVL:	LXI	D,SYMBS
	CALL	SL
	JNZ	GVL1

; ONLY RAISE ALARM FOR MISSING
; IDENTIFIERS ON CODE 2 TO ALLOW
; CODE 1 TO COLLECT THEM AT A
; LEISURELY PACE
	LDA	FUNC
	ANI	2
	JZ	GVC

; SYMBOL NOT FOUND ERROR
	MVI	A,4
	JMP	FAIL

; A FORWARD SYMBOL REFERENCE
; MUST RESOLVE TO A 16 BIT VALUE
; BUT THE SIZE OF A BACKWARD
; REFERENCE CAN BE 8 BITS AND
; DETECTED 8-BIT BACKWARD
; REFERENCES ARE THEREFORE
; MARKED WITH BIT 1 ON THE
; TERMINATOR CHARACTER WHICH
; CODE 2 WILL LOOK FOR;
; CONSEQUENTLY, IT MAY NOT BE
; SET DURING A CODE 2 SEQUENCE
GVL1:	INX	D
	LDAX	D
	CPI	21H
	JNC	GVL1
	MOV	A,B
	ORA	A
	JNZ	GVL3
	LDA	FUNC
	ANI	2
	JNZ	GVL2
	LDAX	D
	ORI	1
	STAX	D
GVL2:	LDAX	D
	ANI	1
	JNZ	GVV
GVL3:	LDA	SYMFLG
	ORI	2
	STA	SYMFLG

; SET IDENTIFIER FLAG
GVV:	LDA	SYMFLG
	ORI	40H
	STA	SYMFLG
	JP	GVNS
	XRI	80H
	STA	SYMFLG

; IF MINUS FLAG IS SET, NEGATE
; ACQUIRED VALUE
	MVI	A,0
	SUB	C
	MOV	C,A
	MVI	A,0
	SBB	B
	MOV	B,A

; CHECK FLAGS FOR ACTIVE SIZE
; OVERRIDES
GVNS:	LDA	SYMFLG
	RAL
	RAL
	RAL
	RAL
	JC	GVWO
	RAL
	JC	GVHB
	RAL
	JC	GVLB
	JMP	GVWO
GVHB:	RAL
	JC	GVWO
	MOV	A,B
	MOV	C,A
GVLB:	MVI	B,0
	LDA	SYMFLG
	ANI	0FCH
	STA	SYMFLG
GVWO:	STC
	CMC
	RET

; --------------------------------
; READ ONE BYTE FROM BINARY BUFFER
RDBIN:	PUSH	H
	MVI	D,0
	LDA	BINLEN
	MOV	E,A
	LHLD	BINBUF
	DAD	D
	INR	A
	STA	BINLEN
	MOV	A,M
	POP	H
	RET

; --------------------------------
; CHECK VALUE FOR SYMBOL AND
; WRITE SYMBOL IF DETECTED
WSYMA:	LDA	FUNC
	ANI	3
	JZ	WSYMA4
	LXI	D,SYMBS
	CALL	SDEF
	MVI	A,0
	JZ	WSYMA1

; TRY SYMBOL-1
	PUSH	H
	LHLD	IMM
	INX	H
	SHLD	IMM
	POP	H
	LXI	D,SYMBS
	CALL	SDEF
	MVI	A,2DH
	JZ	WSYMA1

; TRY SYMBOL+1
	PUSH	H
	LHLD	IMM
	DCX	H
	DCX	H
	SHLD	IMM
	POP	H
	LXI	D,SYMBS
	CALL	SDEF
	MVI	A,2BH
	JNZ	WSYMA3
WSYMA1:	CPI	0
	PUSH	PSW
	CALL	WRM

; IF THERE'S A SIGN CHARACTER
; IN A, WRITE SIGN AND 1
	POP	PSW
	JZ	WSYMA2
	MOV	M,A
	INX	H
	MVI	M,31H
	INX	H
WSYMA2:	STC
	CMC
	RET

; RESTORE ORIGINAL VALUE
WSYMA3:	PUSH	H
	LHLD	IMM
	INX	H
	SHLD	IMM
	POP	H
WSYMA4:	STC
	RET

; --------------------------------
; WRITE DE TO HL
WRM:	LDAX	D
	MOV	M,A
	INX	D
	INX	H
	CPI	20H
	JNC	WRM
	DCX	H
	RET

; --------------------------------
; CHECK IF PC WITHIN RECORD BOUNDS
CHKDAT:	MOV	E,M
	INX	H
	MOV	D,M
	INX	H
	MOV	C,M
	INX	H
	MOV	B,M
	LHLD	PC

; IN THIS SEQUENCE, ONLY THE
; CARRY FLAG PROVES SIGNIFICANT.
; FIRST COMPARE PC TO THE LOWER
; BOUNDARY
	MOV	A,H
	CMP	D
	RNZ
	MOV	A,L
	CMP	E
	RC

; THEN COMPARE UPPER BOUNDARY
; TO PC
	MOV	A,B
	CMP	H
	RNZ
	MOV	A,C
	CMP	L
	RC

; --------------------------------
; DFS DIRECTIVE
SETDFS:	CALL	RE
	PUSH	H
	LHLD	IMM
	XCHG
	LHLD	USIZE
	DAD	D
	SHLD	USIZE
	POP	H

; --------------------------------
; STORE DATA AREA ADDRESS
STDAT:	PUSH	H
	LDA	FUNC
	ANI	2
	JZ	STDAT7
	LXI	H,MAPBUF

; SET UP COUNTER
	MOV	C,M
	INX	H
	MOV	B,M
	INX	H

; CHECK COUNTER
STDAT1:	MOV	A,B
	ORA	C
	JZ	STDAT6

; GET BOUNDS
	PUSH	B
	PUSH	H
	CALL	CHKDAT
	JNC	STDAT2

; SKIP TO NEXT RECORD
	POP	H
	LXI	B,4
	DAD	B
	POP	B
	DCX	B
	JMP	STDAT1

; CHECK IF DATA AREA FITS
; ENTIRELY
STDAT2:	XCHG
	LHLD	IMM
	DAD	D
	XCHG
	MOV	A,H
	CMP	D
	JNZ	STDAT3
	MOV	A,L
	CMP	E
STDAT3:	POP	H
	POP	B
	JC	STDAT7
	JZ	STDAT7
	DCX	H
	DCX	H
	MOV	M,E
	INX	H
	MOV	M,D
	JMP	STDAT7

; STORE NEW RECORD
STDAT6:	PUSH	H
	LHLD	PC
	XCHG
	LHLD	IMM
	DAD	D
	MOV	B,H
	MOV	C,L
	POP	H
	MOV	M,E
	INX	H
	MOV	M,D
	INX	H
	MOV	M,C
	INX	H
	MOV	M,B

; ADVANCE PC
STDAT7:	LHLD	PC
	XCHG
	LHLD	IMM
	DAD	D
	SHLD	PC
	POP	H
	STC
	CMC
	RET

; --------------------------------
; SCAN FOR DATA AREA ADDRESS
LDDAT:	LDA	FUNC
	ANI	2
	RZ
	PUSH	H
	LXI	H,MAPBUF

; SET UP COUNTER
	MOV	C,M
	INX	H
	MOV	B,M
	INX	H

; CHECK COUNTER
LDDAT1:	MOV	A,B
	ORA	C
	JNZ	LDDAT3
	POP	H
	RET

; GET BOUNDS
LDDAT3:	PUSH	B
	PUSH	H
	CALL	CHKDAT
	POP	H
	JC	LDDAT4
	POP	B
	POP	H
	ORI	1
	RET

; SKIP TO NEXT RECORD
LDDAT4:	LXI	B,4
	DAD	B
	POP	B
	DCX	B
	JMP	LDDAT1
