; --------------------------------
; ASSEMBLE ONE LINE
ASM:	XOR	AX,AX

; SAVE STACK SO EVERY ERROR
; CAN RETURN HERE REGARDLESS OF
; STACK CONTENTS
	MOV	[STK],SP
	MOV	[BINLEN],AX
	MOV	SI,TXTBUF
	MOV	AL,[FUNC]
	TEST	AL,AL
	JNS	ASMLIN
	CLD
	MOV	DI,TXTBUF

; WRITE LABEL IF SYMBOLS ARE TO
; BE READ
	TEST	AL,2
	JZ	NOSYM
	MOV	AX,[PC]
	MOV	SI,SYMBS
	MOV	CL,0CH
	CALL	SDEF
	JNZ	NOSYM

; WRITE SYMBOL IF IT IS NOT
; AN EQUATE OR BLANK
	DEC	BX
	TEST	BYTE [BX+SI],2
	JNZ	NOSYM
	CALL	WRM
	MOV	AL,3AH
	STOSB
NOSYM:	MOV	SI,BINBUF
	LODSB
	MOV	[OPCODE],AL
	MOV	AL,9
	STOSB
	CALL	DISASM
	MOV	AX,0A0DH
	STOSW
	MOV	AX,DI
	SUB	AX,TXTBUF
	MOV	[TXTLEN],AX
	MOV	AX,[BINLEN]
	ADD	[PC],AX
	CLC
	RET
ASMLBL:	CALL	LBL

; RESET STACK JUST IN CASE WE
; GOT BACK HERE FROM SOME OR
; OTHER ODD PLACE
ASMLIN:	MOV	SP,[STK]
	CALL	CC
	JZ	SETEQ0

; EQUAL SIGN WORKS LIKE AN EQU
	CMP	AL,3DH
	JE	ASMEQU

; SET PROGRAM COUNTER BY CHARACTER
	CMP	AL,PCCHAR
	JE	ASMORG
	CALL	ASMCMD
	JNZ	ASMLBL
	CALL	CC
	JZ	SETEQ0

; CHARACTERS PAST END OF LINE
; ERROR
	MOV	AL,9
	JMP	FAIL
ASMEQU:	INC	SI

; --------------------------------
; EQU DIRECTIVE OR EQUAL SIGN
SETEQU:	MOV	AL,[FUNC]
	TEST	AL,3
	JZ	SETEQ0

; GET OR CALCULATE IMMEDIATE
; AND STORE IT AT POINTER
; GENERATED BY LBL
	CALL	RE
	MOV	DI,BP
	OR	BYTE [DI-1],2
	STOSW
SETEQ0:	CLC
	RET
ASMORG:	INC	SI
	CALL	CC
	JZ	ASMOER
	CMP	AL,3DH
	JNE	ASMOER
	INC	SI

; --------------------------------
; ORG DIRECTIVE
SETORG:	CALL	RE
	MOV	DX,[PC]
	MOV	[PC],AX

; CHECK FOR START OF PROGRAM
	CMP	DX,[VORG]
	JE	SETOR2

; IF NEW ADDRESS IS AHEAD,
; DEFINE AS EMPTY SPACE
	SUB	AX,DX
	JB	SETOR1
	ADD	[USIZE],AX
SETOR1:	CLC
	RET

; SET LOAD ADDRESS AT
; PROGRAM START
SETOR2:	MOV	[SYMBS+3],AX
	CLC
	RET

; SYNTAX ERROR
ASMOER:	MOV	AL,1
	JMP	FAIL

; --------------------------------
; SCAN FOR TOKENS AT TXTBUF
; SET SI TO FIRST TOKEN
; LOCATION, BX TO LENGTH,
; AL TO FIRST CHAR
CC:	XOR	BX,BX
CCM:	MOV	AL,[BX+SI]
	CMP	AL,0
	JE	CCT
	CMP	AL,0DH
	JE	CCT
	CMP	AL,21H
	JB	CCK
	CMP	AL,22H
	JE	CCQ
	CMP	AL,27H
	JE	CCQ
	CMP	AL,30H
	JB	CCS
	CMP	AL,3AH
	JB	CCL
	CMP	AL,3BH
	JE	CCT
	CMP	AL,41H
	JB	CCS
	CMP	AL,5BH
	JB	CCL
	CMP	AL,5FH
	JE	CCL
	CMP	AL,61H
	JB	CCS
	CMP	AL,7BH
	JNB	CCS

; CONVERT NORMAL LETTER
; TO UPPERCASE
	AND	AL,0DFH
	MOV	[BX+SI],AL

; INCREMENT TOKEN LENGTH
CCL:	INC	BX
	JMP	SHORT CCM

; IF THERE IS A TOKEN, ABORT
; AND RETURN IT, OTHERWISE
; SKIP SPACE
CCK:	TEST	BX,BX
	JNZ	CCT
	INC	SI
	JMP	SHORT CCM

; IF THERE IS ALREADY A TOKEN
; ABORT AND RETURN EXISTING
; TOKEN, OTHERWISE RETURN
; SPECIAL CHARACTER
CCS:	TEST	BX,BX
	JZ	CCE

; ABORT AND RETURN FIRST
; CHARACTER ON LINE AND
; SET ZERO FLAG
CCT:	MOV	AL,[SI]
	TEST	BX,BX
	RET

; IF TOKEN EXISTS, ABORT AND
; RETURN TOKEN, OTHERWISE
; SCAN UNTIL NEXT MATCHING
; QUOTE AND RETURN QUOTED
; TEXT AS TOKEN
CCQ:	TEST	BX,BX
	JNZ	CCT
CCW:	INC	BX
	CMP	AL,[BX+SI]
	JNZ	CCW
CCE:	INC	BX
	RET

; --------------------------------
; TEST IF 16-BIT SIGNED NUMBER
; CAN UNAMBIGUOUSLY FIT WITHIN
; 8 BITS
AA:	TEST	AL,80H
	JNZ	AA1

; IF SIGN BIT IS NOT SET ON
; LOWER BYTE, UPPER BYTE MUST
; BE ZERO
	TEST	AH,AH
	RET

; IF SIGN BIT IS SET ON LOWER
; BYTE, UPPER BYTE MUST BE FF
AA1:	CMP	AH,0FFH
	RET

; --------------------------------
; SCAN SYMBOL TABLE FOR TOKEN
; AND RETURN DEFINITION IF FOUND
SL:	MOV	DX,[DI]
	MOV	CX,BX

; ADVANCE TABLE POINTER, ADD
; 2 BYTES FOR DEFINITION
SL1:	INC	DI
	INC	DI
	MOV	BX,CX

; DECREMENT COUNTER
	DEC	DX
	JS	SL6

; GET ENTRY LENGTH AND CHECK
; WITH SYMBOL; SET BX TO -1
; FIRST TO BE ABLE TO
; PREINCREMENT
	STC
	SBB	BX,BX
	MOV	AL,20H
SL2:	INC	BX
	CMP	AL,[BX+DI]
	JB	SL2
	CMP	BX,CX
	JNE	SL4

; CHECK ENTRY AGAINST SYMBOL
SL3:	DEC	BX
	JS	SL5
	MOV	AL,[BX+SI]
	CMP	AL,[BX+DI]
	JE	SL3
	MOV	BX,CX
SL4:	ADD	DI,BX
	INC	DI
	JNE	SL1

; LOAD DEFINITION INTO AX
SL5:	MOV	BX,CX
	MOV	AX,[BX+DI+1]
	ADD	SI,BX
	CMP	BX,BX
SL6:	RET

; --------------------------------
; SCAN SYMBOL TABLE BY AX FOR
; DEFINITION, ACCORDING TO CL,
; AND RETURN SYMBOL
SDEF:	MOV	DX,[SI]
	ADD	SI,3
	DEC	DX
	JNZ	SDEF7
	DEC	DX
	RET

; GET ENTRY LENGTH
SDEF1:	STC
	SBB	BX,BX
SDEF2:	INC	BX
	CMP	BYTE [BX+SI],21H
	JNB	SDEF2
	INC	BX

; CHECK DEFINITION
	TEST	CL,0CH
	JZ	SDEF3
	TEST	CL,8
	JZ	SDEF4
	TEST	CL,4
	JZ	SDEF5

; FULL WORD
	CMP	[BX+SI],AX
	JNE	SDEF6
	RET

; SIGNED BYTE
; FALLS THROUGH TO LOW BYTE
SDEF3:	TEST	BYTE [BX+SI+1],0FFH
	JZ	SDEF4
	CMP	BYTE [BX+SI+1],0FFH
	JNE	SDEF6
	TEST	BYTE [BX+SI],0FFH
	JNS	SDEF6

; LOW BYTE
SDEF4:	CMP	[BX+SI],AL
	JNE	SDEF6
	RET

; HIGH BYTE
SDEF5:	CMP	[BX+SI+1],AL
	JNE	SDEF6
	RET

; SKIP ENTRY ENTIRELY
SDEF6:	ADD	SI,BX

; ACTUAL START OF LOOP, SINCE
; THE TABLE STARTS ON A TWO-BYTE
; VALUE; PREDECREMENTING DX
; WILL ALSO RESET THE ZERO FLAG
; ONCE IT'S RUN THROUGH WITH
; NO RESULT
SDEF7:	INC	SI
	INC	SI
	DEC	DX
	JNS	SDEF1
	RET

; --------------------------------
; HUMDRUM HEX CONVERT
HALX:	PUSH	AX
	SHR	AL,1
	SHR	AL,1
	SHR	AL,1
	SHR	AL,1
	CALL	HALL
	POP	AX
HALL:	AND	AL,0FH
	OR	AL,30H
	CMP	AL,3AH
	JB	HALN
	ADD	AL,7

; WRITE CHARACTER TO
; TEXT BUFFER
HALN:	STOSB
	RET

; --------------------------------
; READ 16-BIT NUMBER IN EITHER
; BINARY, OCTAL, HEX, OR DECIMAL
; AS DEFINED BY ROTATION COUNT
; IN CL
RN:	CLD

; BLANK OUT TEMPORARY STORAGE
	XOR	DX,DX

; CL BETWEEN 1 AND 4 WORKS WITH
; COMMON NUMBER BASES THAT ARE
; POWERS OF 2.  ANYTHING ELSE
; IS CHANGED TO ZERO WHICH WORKS
; WITH DECIMAL
	CMP	CL,5
	JB	RN1
	XOR	CL,CL
RN1:	TEST	CL,CL
	JNZ	RN2

; IF NOTHING IN CL, CONTINUE
; PROCESSING AS DECIMAL
	SHL	DX,1
	MOV	AX,DX
	SHL	DX,1
	SHL	DX,1
	ADD	DX,AX
RN2:	SHL	DX,CL

; READ ONE DIGIT FROM LINE
; AND USE ALL OF AX FOR IT
	XOR	AH,AH
	LODSB
	SUB	AL,30H

; ANYTHING BELOW $30 WILL
; UNDERFLOW OUT OF ITS VALID
; DIAPAZON AND WILL NOT PASS THE
; FOLLOWING UPPER BOUNDARY TESTS
	CMP	AL,0AH
	JB	RN3
	SUB	AL,7
	CMP	AL,0FH
	JNBE	RN0
RN3:	ADD	DX,AX
	DEC	BX
	JNZ	RN1

; IF THE TOKEN IS FULLY
; PROCESSED, BX WILL END UP
; TRIGGERING THE ZERO FLAG.  IF
; EXITED VIA THE EARLIER JUMP,
; THE ZERO FLAG ISN'T SET,
; SIGNALING AN INVALID DIGIT.
RN0:	RET

; --------------------------------
; WRITE 16-BIT NUMBER TO TEXT
; BUFFER AS A NUMERIC CONSTANT
; WITHOUT LEADING ZEROES
; IN BASE SPECIFIED BY CX
WN:	CLD
	CMP	AX,CX
	JNB	WN1
	CMP	AX,0AH
	JNB	WN1

; NO NEED FOR A LONG RIGMAROLE
; IF THERE'S ONLY ONE DIGIT
	OR	AL,30H
	STOSB
	RET
WN1:	MOV	SI,DI
WN2:	XOR	DX,DX

; DIVIDE BY BASE AND GET
; REMAINDER FOR EACH DIGIT
	DIV	CX
	XCHG	AX,DX

; A VARIATION ON
; ALLISON'S ALGORITHM
	CMP	AL,0AH
	SBB	AL,69H
	DAS
	STOSB
	XCHG	AX,DX
	TEST	AX,AX
	JNZ	WN2

; DIGITS ARE WRITTEN TO BUFFER
; BACKWARDS AT FIRST, AND THE
; FINAL ONE WRITTEN IS THE
; FIRST DIGIT--IF IT IS NOT A
; NUMERIC, IT REQUIRES A
; LEADING ZERO
	CMP	DL,3AH
	JB	WN5
	MOV	AL,30H
	STOSB

; REVERSE ORDER OF DIGITS IN
; TEXT BUFFER
WN5:	MOV	CX,DI
	SUB	CX,SI
	SHR	CX,1

; UNLESS THERE'S ONLY ONE
	JZ	WN0
	SUB	DI,CX
	ADD	SI,CX
WN4:	DEC	SI
	MOV	AL,[DI]
	XCHG	[SI],AL
	STOSB
	LOOP	WN4
WN0:	RET

; --------------------------------
; ADD SYMBOL TO SYMBOL TABLE
; OR REDEFINE EXISTING SYMBOL
LBL:	CALL	CC
	MOV	AL,[FUNC]
	AND	AL,3
	JZ	ERR3

; PROCESS DETECTED SYMBOL
	MOV	DI,SYMBS
	CALL	SL
	JNZ	LBL1

; SYMBOL EXISTS, BUT CAN BE
; REDEFINED ON FUNCTION 2
	ADD	DI,BX
	INC	DI
	MOV	AL,[FUNC]
	AND	AL,2
	JNZ	LBL2

; DUPLICATE SYMBOL ERROR
	MOV	AL,0AH
	JMP	FAIL

; WRITE SYMBOL TO TABLE
LBL1:	MOV	CX,BX
	CLD
	REP MOVSB
	XOR	AL,AL
	STOSB

; INCREASE SYMBOL COUNT
	INC	WORD [SYMBS]

; SAVE POINTER TO ENTRY
LBL2:	MOV	BP,DI

; GET CURRENT PROGRAM COUNTER
; AND STORE IN TABLE WITH THE
; NEW ENTRY
	MOV	AX,[PC]
	STOSW

; CHECK FOR COLON OR INSTRUCTION
	CALL	CC
	JZ	ERR3
	CMP	AL,3AH
	JNE	LBL3

; SKIP COLON
	INC	SI
LBL3:	RET

; INVALID INSTRUCTION ERROR
ERR3:	MOV	AL,3
	JMP	FAIL

; --------------------------------
; PROCESS DFB/DFW DIRECTIVE
SETDFB:	MOV	DI,BINBUF
	XOR	CX,CX
SETDMA:	CALL	CC
	JZ	ERR8
	CMP	AL,3FH
	JE	SETDUD

; DEFINED DATA IS DISCOVERED SO
; WRITE ALL PRECEDING UNDEFINED
; DATA TO BUFFER AS ZEROES;
; IF NONE, REP WILL EXECUTE
; ZERO TIMES
	PUSH	AX
	XOR	AX,AX
	REP STOSB
	POP	AX
	CMP	AL,22H
	JE	SETDQU
	CMP	AL,27H
	JE	SETDQU
SETDVA:	PUSH	CX
	PUSH	DI
	CALL	RE
	POP	DI
	POP	CX
	STOSW

; STORE ONLY THE NECESSARY
; AMOUNT OF BYTES
	CMP	BYTE [OPCODE],2
	JE	SETDCM
	JNB	SETDVW
	DEC	DI
	JMP	SHORT SETDCM

; VALUES LARGER THAN 16 BITS
; ARE SIGN EXTENDED TO FILL
SETDVW:	SHL	AX,1
	SBB	AL,AL
	PUSH	CX
	MOV	CL,[OPCODE]

; ALREADY HAVE TWO BYTES OF
; VALUE STORED
	SUB	CL,2
	REP STOSB
	POP	CX
	JMP	SHORT SETDCM

; IF ANY UNDEFINED DATA IS
; FOUND, ADD IT UP
SETDUD:	ADD	CL,[OPCODE]
	INC	SI
	JMP	SHORT SETDCM

; QUOTED STRINGS OF LESS THAN 3
; BYTES ARE PROCESSED AS LITERAL
; BINARY CONSTANTS
SETDQU:	MOV	AL,[OPCODE]
	ADD	AL,3
	CMP	BL,AL
	JB	SETDVA
	PUSH	CX
	MOV	CX,BX

; WRITE ONLY WHAT IS BETWEEN THE
; QUOTATION MARKS AND SKIP MARKS
	SUB	CX,2
	INC	SI
	REP MOVSB
	INC	SI
	POP	CX

; IF THERE ARE ANY MORE
; CHARACTERS ON THE LINE, THE
; FIRST MUST BE A COMMA
SETDCM:	CALL	CC
	JZ	SETDEN
	CMP	AL,2CH
	JNE	ERR1
	INC	SI
	JMP	SHORT SETDMA

; ADD ANY UNDEFINED DATA TO THE
; ACCUMULATED AMOUNT AND UPDATE
; PC BY THE SAME AMOUNT.  THE
; ASM PROCEDURE WILL UPDATE PC
; BY THE LENGTH OF THE BINARY
; OUTPUT PRODUCED, I.E. HOW FAR
; THE BUFFER HAS BEEN SKIPPED
SETDEN:	ADD	[USIZE],CX
	MOV	AX,DI
	SUB	AX,BINBUF
	MOV	[BINLEN],AX
	ADD	AX,CX
	JMP	STDAT

; MISSING OPERAND ERROR
ERR8:	MOV	AL,8
	JMP	SHORT FAIL

; SYNTAX ERROR
ERR1:	MOV	AL,1
	JMP	SHORT FAIL

; --------------------------------
; PREPARE FILE NAME FOR
; INCLUDE DIRECTIVE
SETINC:	CALL	CC
	JZ	ERR8
	CMP	AL,22H
	JE	SETIN1
	CMP	AL,27H
	JNE	SETIN2
SETIN1:	INC	SI

; IF ENCLOSED IN QUOTES, MUST
; BE AT LEAST 3 CHARACTERS LONG
; INCLUDING THE TWO MARKS
	SUB	BX,2
	JBE	ERR8
	JMP	SHORT SETEND

; IF NOT IN QUOTES, GET REST
; OF LINE UNTIL FIRST EMPTY
; SPACE OR SEMICOLON
SETIN2:	XOR	BX,BX
SETIN3:	INC	BX
	MOV	AL,[BX+SI]
	CMP	AL,3BH
	JE	SETEND
	CMP	AL,21H
	JNB	SETIN3

; PROCEED DIRECTLY INTO THE
; I/O HANDLER
SETEND:	MOV	AL,[OPCODE]

; --------------------------------
; ERROR AND I/O HANDLER
FAIL:	MOV	SP,[STK]

; FIRST RESET STACK TO TOP LEVEL
; CALLER, THE LINE ASSEMBLER
	CMP	AL,5
	JNE	FAIL2

; ERROR CODE 5 IS RELATIVE JUMP
; OUT OF RANGE; CALCULATE THE
; ABSOLUTE AMOUNT OF BYTES
	MOV	DX,[IMM]
	TEST	DX,DX
	JNS	FAIL1
	NOT	DX
FAIL1:	SUB	DX,7FH
FAIL2:	STC
	RET

; --------------------------------
; PRIMITIVE EXPRESSION EVALUATOR
RE:	XOR	CL,CL
	XOR	AX,AX
	MOV	[IMM],AX
REA:	CALL	CC
	JZ	RED

; PREPARE TO SET ARITHMETIC
; OPERATOR FLAGS
	CMP	AL,2BH
	JE	REC
	CMP	AL,2DH
	JE	REB

; GV WILL APPLY THE OPERATOR
; AND RESET ITS FLAG
	CALL	GV
	JC	RED

; IF AN IDENTIFIER WAS FOUND,
; GV HAS SET ITS FLAG INSTEAD
	ADD	[IMM],AX
	JMP	SHORT REA

; USE OF AN OPERATOR WILL RESET
; THE IDENTIFIER FLAG
REB:	XOR	CL,80H
REC:	AND	CL,0BFH
	INC	SI
	JMP	SHORT REA

; CHECK FOR OPERAND TO MAKE
; SURE THERE ARE NO DANGLING
; OPERATORS
RED:	TEST	CL,40H
	JZ	ERR8
	MOV	AX,[IMM]
	RET

; --------------------------------
; HANDLE ONE NUMERIC CONSTANT
; OR IDENTIFIER AND GET VALUE
GV:	TEST	CL,40H

; CHECK FLAGS IF IDENTIFIER WAS
; ALREADY PROCESSED
	JNZ	GVA
	CMP	AL,PCCHAR
	JE	GVC
	CMP	AL,22H
	JE	GVQ
	CMP	AL,27H
	JE	GVQ

; CHECK SIZE OVERRIDES AND START
; OVER IF THERE ARE ANY
	CALL	RNM
	JZ	GV
	CALL	RNC
	JNC	GVV

; INVALID CHARACTERS MEANS THE
; END OF THE IDENTIFIER
	CMP	AL,40H
	JB	GVA
	MOV	AL,[FUNC]
	AND	AL,3
	JNZ	GVL

; ONLY BOTHER READING LABELS
; IF THE FUNCTION IS SPECIFIED
; OTHERWISE JUST GET CURRENT PC
GVC:	ADD	SI,BX
	OR	CL,1
	MOV	DX,[PC]
	JMP	SHORT GVV

; RETURN WITH CARRY MEANS
; UNEXPECTED ENTRY OR END
; OF LINE
GVA:	STC
	RET

; SAVE TWO PLACES PAST FIRST
; QUOTATION MARK
GVQ:	MOV	DX,[SI+1]
	ADD	SI,BX

; 5 CHARACTERS INCLUDING 2
; QUOTES MEANS 3 CHARACTER VALUE
; AND THAT IS EXCESSIVE
	CMP	BX,5
	JNB	GV7

; 2 CHARACTER VALUE MEANS WHAT
; WAS SAVED IS GOOD
	CMP	BX,4
	JNB	GVV

; 0 CHARACTER VALUE CANNOT BE
	CMP	BX,3
	JB	GV8

; 1 CHARACTER MEANS UPPER BYTE
; OF TEMP VALUE MUST BE BLANKED
	XOR	DH,DH
	JZ	GVV

; CONSTANT TOO LARGE ERROR
GV7:	MOV	AL,7
	JMP	FAIL

; MISSING OPERAND ERROR
GV8:	MOV	AL,8
	JMP	FAIL

; PROCESS SYMBOL REFERENCE
GVL:	PUSH	CX
	MOV	DI,SYMBS
	CALL	SL
	POP	BX

; RESTORE BX AS IT IS ZERO
; AFTER SKIPPING TOKEN
	XCHG	BX,CX
	MOV	DX,102H
	XCHG	DX,AX
	JZ	GVL1

; ONLY RAISE ALARM FOR MISSING
; IDENTIFIERS ON CODE 2 TO ALLOW
; CODE 1 TO COLLECT THEM AT A
; LEISURELY PACE
	TEST	AL,[FUNC]
	JZ	GVC

; SYMBOL NOT FOUND ERROR
	MOV	AL,4
	JMP	FAIL

; A FORWARD SYMBOL REFERENCE
; MUST RESOLVE TO A 16 BIT VALUE
; BUT THE SIZE OF A BACKWARD
; REFERENCE CAN BE 8 BITS AND
; DETECTED 8-BIT BACKWARD
; REFERENCES ARE THEREFORE
; MARKED WITH BIT 1 ON THE
; TERMINATOR CHARACTER WHICH
; CODE 2 WILL LOOK FOR;
; CONSEQUENTLY, IT MAY NOT BE
; SET DURING A CODE 2 SEQUENCE
GVL1:	TEST	DH,DH
	JNZ	GVL3
	TEST	AL,[FUNC]
	JNZ	GVL2
	OR	[BX+DI],AH
GVL2:	TEST	[BX+DI],AH
	JNZ	GVV
GVL3:	OR	CL,2

; SET IDENTIFIER FLAG
GVV:	OR	CL,40H
	TEST	CL,CL
	JNS	GVNS
	XOR	CL,80H

; IF MINUS FLAG IS SET, NEGATE
; ACQUIRED VALUE
	NEG	DX

; CHECK FLAGS FOR ACTIVE SIZE
; OVERRIDES
GVNS:	TEST	CL,10H
	JNZ	GVWO
	TEST	CL,8
	JNZ	GVHB
	TEST	CL,4
	JNZ	GVLB
	JMP	SHORT GVWO
GVHB:	TEST	CL,4
	JNZ	GVWO
	XCHG	DL,DH
GVLB:	XOR	DH,DH
	AND	CL,0FCH
GVWO:	MOV	AX,DX
	CLC
	RET

; --------------------------------
; CHECK VALUE FOR SYMBOL AND
; WRITE SYMBOL IF DETECTED
WSYMA:	TEST	BYTE [FUNC],3
	JZ	WSYMA4
	PUSH	SI
	XOR	CH,CH
	MOV	SI,SYMBS
	CALL	SDEF
	JZ	WSYMA1

; TRY SYMBOL-1
	INC	AX
	MOV	CH,2DH
	MOV	SI,SYMBS
	CALL	SDEF
	JZ	WSYMA1

; TRY SYMBOL+1
	DEC	AX
	DEC	AX
	MOV	CH,2BH
	MOV	SI,SYMBS
	CALL	SDEF
	JNZ	WSYMA3
WSYMA1:	CALL	WRM

; IF THERE'S A SIGN CHARACTER
; IN X, WRITE SIGN AND 1
	TEST	CH,CH
	JZ	WSYMA2
	MOV	AH,31H
	MOV	AL,CH
	STOSW
WSYMA2:	POP	SI
	CLC
	RET

; RESTORE ORIGINAL VALUE
WSYMA3:	INC	AX
	POP	SI
WSYMA4:	STC
	RET

; --------------------------------
; WRITE SI TO DI
WRM:	CLD
	LODSB
	STOSB
	CMP	AL,20H
	JNB	WRM
	DEC	DI
	RET

; --------------------------------
; DFS DIRECTIVE
SETDFS:	CALL	RE
	ADD	[USIZE],AX

; --------------------------------
; STORE DATA AREA ADDRESS
STDAT:	PUSH	SI
	TEST	BYTE [FUNC],2
	JZ	STDAT4
	MOV	SI,MAPBUF+2
	MOV	CX,[MAPBUF]
	JCXZ	STDAT3
STDAT1:	MOV	DX,[PC]

; CHECK IF PC WITHIN RECORD BOUNDS
	CMP	DX,[SI]
	JB	STDAT2
	CMP	[SI+2],DX
	JB	STDAT2

; CHECK IF DATA AREA FITS
; ENTIRELY
	ADD	DX,AX
	CMP	DX,[SI+2]
	JBE	STDAT4

; EXTEND RECORD LENGTH AND QUIT
	MOV	[SI+2],DX
	JMP	SHORT STDAT4

; SKIP TO NEXT RECORD
STDAT2:	ADD	SI,4
	LOOP	STDAT1

; STORE NEW RECORD
STDAT3:	MOV	DX,[PC]
	MOV	[SI],DX
	ADD	DX,AX
	MOV	[SI+2],DX
	INC	WORD [MAPBUF]
STDAT4:	POP	SI

; ADVANCE PC
	ADD	[PC],AX
	CLC
	RET

; --------------------------------
; SCAN FOR DATA AREA ADDRESS
LDDAT:	PUSH	SI
	TEST	BYTE [FUNC],2
	JZ	LDDAT3
	MOV	SI,MAPBUF+2
	MOV	CX,[MAPBUF]
	JCXZ	LDDAT3
LDDAT1:	MOV	AX,[PC]

; CHECK IF PC WITHIN RECORD BOUNDS
	CMP	AX,[SI]
	JB	LDDAT2
	MOV	AX,[SI+2]
	SUB	AX,[PC]
	JC	LDDAT2
	POP	SI
	RET

; SKIP TO NEXT RECORD
LDDAT2:	ADD	SI,4
	LOOP	LDDAT1
LDDAT3:	POP	SI
	STC
	RET
